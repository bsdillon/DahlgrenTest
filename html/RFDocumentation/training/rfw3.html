<!DOCTYPE html>
<html>
  <head>
    <title>Robot Framework Training</title>
    <link href = "./../../common.css" rel = "stylesheet">
    <script>
    </script>
  </head>
  <body>
    <h2>Robot Framework Training</h2>

    <h3>Table of Contents</h3>
    <ul>
      <li><a href="#"></a></li>
    </ul>

    <a name="overview"></a><h3>Overview</h3>
    <p>
      This section covers the instructions for setup, development, and use of
      Robot Framework. Robot Framework or RFW is a free set of libraries that
      can be used to enable automatic testing. RFW is flexible and can easily
      incorporate any tool or library through the Python language. In the course
      of events, Dahlgren has developed a set of external files that assist in
      and enhance the experience using RFW. This is the third set of such 
      libraries and thuse we refer to it as RFW 3.0.
    </p>

    <a name="configuration"></a><h2>Configuration</h2>
    <a name="downloads"></a><h3>Full Download List</h3>
    <h4>Redhat Distribution</h4>
    <ul>
      <li>Python3X<span class="red"><sup>*</sup></span></li>
      <li>Python3X<span class="red"><sup>*</sup></span>-libs</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-pip</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-setuptools</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-tkinter</li>
      <li>tcl</li>
      <li>tk</li>
      <li>tesseract-devel</li>
      <li>tesseract</li>
      <li>leptonica</li>
      <li>leptonica-devel</li>
      <li>java-XXXX-openjdk-devel</li>
      <span class="red">*</span> - See <a href="#versions">discussion of python version</a>
    </ul>
    <h4>Python Libraries</h4>
    <ul>
      <li>pillow [<a href="https://pypi.org/project/Pillow/#history">link</a>]</li>
      <li>Py4J [<a href="https://pypi.org/project/py4j/">link</a>]</li>
      <li>robotframework</li>
    </ul>
    <h4>Other</h4>
    <ul>
      <li><a href="deployment.zip" download target="_blank">RFW 3.0</a></li>
      <li>SikuliX Jar [<a href="https://raiman.github.io/SikuliX1/downloads.html">link</a>]</li>
      <li>Py4J Jar - Downloaded with Py4J python.</li>
    </ul>

    <a name="operatingsystem"></a><h3>Operating System</h3>
    <p>
      RFW 3.0 works on Windows and should be compatible with any operating 
      system. These instructions, however, are written for a Red Hat 
      Enterprise Linux machine. If you are using a different operating 
      system you may have to adapt them for your system.
    </p>

    <a name="versions"></a><h3>Versions</h3>
    <p>
      The download list is very dependent on the version of python selected.
      Robot Framework works with Python 3.6+. The code in RFW 3.0 was written
      for Python 3.10.8. You are free to pick any version of python which your
      site will support subject to those constraints. If you pick a version <em>between</em>
      the two ends you may have to roll back some of the more recent python
      syntax found in the libraries. Whatever version of python you 
      choose, you must use the same version for all RHEL distribution files.
      In these instructions we will simply refer to the selected version as
      python3X.
    </p>
    <p>
      There are two other version issues to consider in these downloads:<br>
      <ul>
        <li>
          There is a <a href="https://pillow.readthedocs.io/en/stable/installation.html">table</a>
          which shows dependencies between python and Pillow. Make sure you 
          install a verison of pillow that works with the selected python3X.
        </li>
        <li>
          SikuliX works only with Java 8+. You may use any version of Java above
          that version.
        </li>
      </ul>
    </p>

    <a name="packages"></a><h3>Installing RHEL Packages</h3>
    <p>
      Each of the RHEL packages must be installed by the root (or SUDO) 
      role using the command <code>yum install <i>package-name</i></code>. It
      is recommended that you install tkinter, pip, tesseract-devel, and java-devel.
      All the rest are installed as dependencies. After installing the packages, 
      find the command for python 3 in your system using <code>which python3</code>
      or you can search the <code>/user/bin/</code> folder. Sometimes the
      system assigns names like python3.X depending on the selected version.
    </p>

    <a name="pipinstall"></a><h3>Python Pip Installs</h3>
    <p>
      If you are attached to the web you can automatically download and install
      python libraries using <code>python3 -m pip install <i>package</i></code>.
      In the case of pillow you can specify the desired version number by adding
      <code>python3 -m pip install pillow==<i>version_number</i></code>. If you 
      are installing offline, you may point to any downloaded library path using
      <code>python3 -m pip install <i>PATH</i></code>.
    </p>

    <a name="paths"></a><h3>Setting Paths</h3>
    <p>
      When the Py4J is pip-installed, it should savea  Java Jar file on your system.
      This is usually found in /usr/share/py4j or /usr/local/share/py4j. Locate
      this Jar file. You will need to add that Jar file and the Sikuli Jar to your
      CLASSPATH variable. This will ensure that they can be found during compilation
      of the Sikuli Entry Point. For similar reasons, you will need to create/update
      the runRobot.bat. This file is found in the RFW 3.0 deployment under RFTest and
      it adds critical python file locations to a the PYTHONPATH and PATH variables.
      The cricial locations are the widgets and OQE folders. 
    </p>

    <a name="validation"></a><h3>System Validation</h3>
    <p>
      There are a number of libraries involved in making a successful RFW 3.0 
      configuration but the system can be validated pretty quickly by testing
      a few effects. We will lead you through them as part of this tutorial.
    </p>

  <h1>Not yet incorporated</h1>
  <p>This is text from an older version which we are reusing</p>

    <a name="session3"></a></a><h2>Refactoring and the OQE Library</h2>
    <p>
      Start from the script you created in the previous activity. If you would prefer, you
      can work from the solution script provided. The examples in these instructions will follow
      from that script. This activity will explain refactoring, a process for periodic review and
      improvement of the reusability of your test scripts. It also makes use of the Objective Quality Evidience (OQE) library
      which Dahlgren developed to directly connect from the RF test scripts to a fully formed
      test report. By gaining familiarity with the OQE library, you can control the format of that
      report.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session3-instr"></a>
      <li>You should regularly consider moving any useful keywords into the resource file. This is a 
          step that increases the reusability of the test. The basic strategy is to work on creating 
          some test capability and then consider how to turn it into a reusable "lego" block for 
          future tests. To do this, it is helpful to identify arguments (sometimes called parameters) 
          in the keyword. A keyword with no arguments is almost literally a one trick pony. With one 
          or more arguments it can be used for many different things.<br><br>

          Here is the original keyword in testSite2.robot. It searches for an element using this 
          specific CSS description. Similarly, the script is finding the value of the <code>id</code> 
          attribute. Those things, however, might vary over many different uses, so we can change 
          them to open arguments.<br><br>

<code>
Find More Button<br>
<in>${id} =&nbsp;&nbsp;&nbsp;&nbsp;Get Element Attribute&nbsp;&nbsp;&nbsp;&nbsp;css:#footer div div div a&nbsp;&nbsp;&nbsp;&nbsp;id</in><br>
<in>Log&nbsp;&nbsp;&nbsp;&nbsp;Found ${id}</in><br><br>
</code>

          This is an updated and more open version of the keyword. It has two <code>arguments</code>
          and we are using them to get the right attribute. We also <code>return</code> the extracted 
          value. This new keyword could be used for any purpose or it could be used for the original 
          purpose.<br><br>

<code>
Find Tag and Get Attribute<br>
<in>[Arguments]&nbsp;&nbsp;&nbsp;&nbsp;${CSS-IDENTIFIER}&nbsp;&nbsp;&nbsp;&nbsp;${ATTRIBUTE-NAME}</in><br>
<in>${value} =&nbsp;&nbsp;&nbsp;&nbsp;Get Element Attribute&nbsp;&nbsp;&nbsp;&nbsp;${CSS-IDENTIFIER}&nbsp;&nbsp;&nbsp;&nbsp;${ATTRIBUTE-NAME}</in><br>
<in>[Return]&nbsp;&nbsp;&nbsp;&nbsp;${value}</in><br><br>
</code>
          </li>
      <li>After building the new keyword from your previous work, call that keyword and verify that 
          the test still works as before. You might call the new keyword like this. Once the test 
          runs and the results are the same I have REFACTORED the script. Refactoring is changing 
          the form, but not the function of the code. It starts and ends with tests that show the 
          changes have not altered the performance of the code. Use the refactoring steps #1 and #2 
          as often as necessary to move generic keywords into an appropriate resource file.<br><br>
<code>
Test Keyword<br>
<in>${id} =&nbsp;&nbsp;&nbsp;&nbsp;Find Tag and Get Attribute&nbsp;&nbsp;&nbsp;&nbsp;css:#footer div div div a&nbsp;&nbsp;&nbsp;&nbsp;id</in><br>
<in>Log&nbsp;&nbsp;&nbsp;&nbsp;Found ${id}</in><br><br>
</code>
      </li>
      <li>In this test we are going to introduce the reporting GUI and use some of those tools to 
          improve the test report beyond what Robot Framework offers natively. We will start by 
          editing a couple of files to set things up. These changes have already been made to your 
          libraries, but you should find and verify these settings for your computer. Open the 
          indicated files and update the file locations. If you are unfamiliar with relative file
          paths <a href="https://desktop.arcgis.com/en/arcmap/10.3/tools/supplement/pathnames-explained-absolute-relative-unc-and-url.htm#GUID-5118AC85-57E4-4027-AC24-FB6E99FADEFF">this site</a>
          has good instructions.<br><br>
          <img src="OQELinks.png"><br>

          <ol>
            <li>In the robot test script, add the resource file for data extraction.<br>
<code>Resource&nbsp;&nbsp;&nbsp;&nbsp;./../OQE/DataExtraction.resource</code>
            </li>
            <li>In the DataExtraction.resource file, give the paths for the two test files.
                Originally, the library accepted two test files, but the current version just
                uses the first. The second one is <span class="red">invalid</span>. The file
                paths are passed from the resource file into the python script.<br>
<code>Library&nbsp;&nbsp;&nbsp;&nbsp;kw_DataExtraction.py&nbsp;&nbsp;&nbsp;&nbsp;&lt;test file&gt;&nbsp;&nbsp;&nbsp;&nbsp;<span class="red">invalid</span>&nbsp;&nbsp;&nbsp;&nbsp;WITH NAME&nbsp;&nbsp;&nbsp;&nbsp;oqe</code>
            </li>
            <li>In the HTML GUI file the data source file needs to match. This is where the 
                GUI will look for data initially and periodically while the script is active.<br>
<code>&lt;body onload="start('./../OQE/test2.js')"&gt;</code>
            </li>
          </ol>    
      </li>
      <li><a name="testconnection">
        We will run a few new test lines just to make sure everything is connected properly. The first
        line sets up the test script for a new event and gives it the name "Test Suite 2". The next 
        four lines call built in keywords built for this kind of check. Test Check is in the resource 
        file and just logs that the resource file is connected. Prove it works is a keyword in the 
        python script and like the previous keyword, it just logs that the python file is connected. 
        Archive Any Previous Data finds the intended data file and stores the contents in an archive 
        folder. This keyword is typically called at the start of any test suite to safely store data 
        from a previous run. As part of this process it also sets up the blank data file in the 
        intended location. The last keyword, Insert Dummy Test Data, puts a few lines of data into 
        the file verifying that the connection is working.<br>
<code>
Setup OQE<br>
<in>New Test Event&nbsp;&nbsp;&nbsp;&nbsp;Test Site 2</in><br>
<in>Test Check</in><br>
<in>${something} =&nbsp;&nbsp;&nbsp;&nbsp;Prove it works</in><br>
<in>Log&nbsp;&nbsp;&nbsp;&nbsp;${something}</in><br>
<in>Archive Any Previous Data</in><br>
<in>Insert Dummy Test Data</in><br><br>
</code>

        After running this test, you can check for the log for the required text. Also open the HTML
        GUI in a browser to verify the dummy data. If you see these effects, then you can be 
        confident everything is connected.<br><br>
        <img src="linkResults.png"><br>
      </li>
      <li>Now edit the test file from the previous activity. Add the DataExtraction resource and 
          make <code>New Test Event</code> the first step of the test. These changes are required
          for each test with the OQE GUI. You may also want to use <code>Archive Any Previous Data</code>
          so that each run exists alone in its own dataset. You can now use the <a href="./../dataextraction/index.html">OQE library</a> instead
          of the native RF capabilities. For the rest of this activity, go through your test and 
          replace the use of OQE. You can work from the library documentation above just as you 
          do with the Selenium library.</li>
    </ol>

    <a name="session3-solut"></a><h3>Solution Scripts</h3>
    <a href="resource3.robot">Resource file</a><br>
    <a href="testSite3.robot">Robot script</a>

<h1>Another section</h1>

 <a name="session4"></a></a><h2>Data Driven Testing</h2>
    <p>
      Start from the script you created in the previous activity. If you would prefer, you
      can work from the solution script provided. The examples in these instructions will follow
      from that script. This time we will explore data driven testing where the same test can have 
      arguments so that it serves for several different test cases. Robot Framework can do this 
      natively or you can use one of several tools to import the data. In any case, the mechanisms 
      are similar. We will look at what RF can do on its own.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session4-instr"></a>
      <li>To set up a group of related tests, you need to go into settings and consider any 
          actions that need to be taken at five key periods. With several tests in a single
          script, these period execute in a predictable series. Each test file can start with
          Suite Setup and end with Suite Teardown. In between, each test of the set uses
          the same Test Setup, Test Template, and Test Teardown. The only difference between
          the tests comes from the data passed into the test as arguments. Thus we are using
          Data Driven Testing.
        <ul>
          <li><code>Suite Setup</code> - this is before any tests occur; best used for setting up 
              any default settings, doctrine, validation, etc.</li>
          <li><code>Test Setup</code> - This runs before each individual test; best used to reset 
              or force a "new test" setting</li>
          <li><code>Test Template</code> - this is the actual test.</li>
          <li><code>Test Teardown</code> - this runs after each individual test; best used to 
              remove any "debris" from the test site</li>
          <li><code>Suite Teardown</code> - this is after all the tests have run; best used to 
              collect final OQE, shut down connections, etc.</li>
        </ul>
        <img src="testLoop.png">
      </li>
      <li>Following the terms above, you MUST add the Test Template keyword. All others are
          optional. Each of these actions MUST be used a keyword. That doesn't mean you only
          get five keywords. You can use any of the five keywords to call others, so you still
          have unlimited flexibility.<br>
<code>
*** Settings ***<br>
Library&nbsp;&nbsp;&nbsp;&nbsp;Selenium<br>
Suite Setup&nbsp;&nbsp;&nbsp;&nbsp;kw_Before All<br>
Test Setup&nbsp;&nbsp;&nbsp;&nbsp;kw_Check Inventory<br>
Test Teardown&nbsp;&nbsp;&nbsp;&nbsp;kw_Clear Status<br>
Test Template&nbsp;&nbsp;&nbsp;&nbsp;kw_Run Test
</code>
      </li>
      <li>
        Unlike the previous activities, a data driven testing script doesn't contain any script under Test Cases
        Instead Test Cases is a table with a single row for each test in the group. Each test has a set of arguments
        included on the same line. All test cases must have the same number of arguments. If an argument is 
        irrelevant for one test case, I suggest using <code>--</code> just to fill that space. You can also put
        names above the arguments to help make the test more readable. It is suggested that you use tabs between 
        arguments for the same reason. Note that the string of text on the far left is the name for that test
        case and can be accessed with the <code>${TEST NAME}</code> variable. Start with one test case and you can build the 
        table over time.<br>
<code>
<table class="wider" cellspacing="20" cellpadding="0">
<tr><td>*** Test Cases ***</td><td>user</td><td>password</td><td>Worded</td><td>Name</td></tr>
<tr><td>Admin login</td><td>admin</td><td>admin</td><td>${TRUE}</td><td>Mr. Admin</td></tr>
<tr><td>Lowly user</td><td>dummy</td><td>password123</td><td>${TRUE}</td><td>Dumbo Jr</td></tr>
<tr><td>No user</td><td>${empty}</td><td>password456</td><td>${FALSE}</td><td>--</td></tr>
<tr><td>No password</td><td>other</td><td>${empty}</td><td>${FALSE}</td><td>--</td></tr>
</table>
</code>
      </li>
      <li>
        In DDT it is important to include the expected outcome as part of your test. These outcomes can be
        used to validate your test on the fly as you are gathering the OQE. In this case, I used a true/false 
        variable just to indicate if the login was successful. I also included the name I expect to see in the
        account section of the page. If I don't get in, I won't check the name (last two cases). I can validate
        these results in my test. Your Test Cases table will include a mixture of directions and data checks.
      </li>
      <li>
        The Test Template keyword is special because it receives all the same arguments laid out in the table.
        On the first line allow space for each of the arguments. Note that you do not have to use the same NAME 
        for the arguments, but you do need to have the same NUMBER.<br>
<code>
*** Keywords ***<br>
kw_Login Test<br>
<in>[Arguments]&nbsp;&nbsp;&nbsp;&nbsp;${user}&nbsp;&nbsp;&nbsp;&nbsp;${password}&nbsp;&nbsp;&nbsp;&nbsp;${worked}&nbsp;&nbsp;&nbsp;&nbsp;${name}</in><br>
</code>
      </li>
      <li>Go through and write your test as before. Use the input data to drive the test, validate it, and report out. There are some 
          <a href="./../best/index.html">pro tips</a> to help you in this process. Here are some suggested steps.<br>
        <ol>
          <li>Take all the test steps you defined in <a href="#session4-instr">activity 3</a> and move them into keywords for this script.
              Now they will be keywords that can be called from the Test Template.</li>
          <li>Make the Test Template keyword call each of those keywords in order. Think of this as your test script with all the details
              in the new keywords.</li>
          <li>Add OQE gathering for each keyword. Keywords are represented as blocks in the OQE GUI. There are also RF keywords which
              capture any defect detected in the keyword. This is a good thing. You might check if X occurred or if Y was found as 
              expected, but if there was anything you missed that RF did find, it will show up in the keyword status.</li>
          <li>Go back to Test Setup and Test Teardown. Are there any actions you need taken before a test to ensure everything is ready
              to roll? How about cleaning up after the fact? Add those if needed. Consider the worse case (that the previous step messed
              everything up). What do you need to do.</li>
          <li>Suite setup and teardown are a bit more abstract as we don't have another suite of tests before or after. Consider what
              would happen if someone had to follow your test. Is there something you should do to ensure the system is in a valid state?
              Is there something you can close that will clear your state entirely? Sometimes signing in/out entirely is just the only
              way to clear that kind of state.</li>
        </ol>
      </li>
    </ol>

    <a name="session4-solut"></a><h3>Solution Scripts</h3>
    <a href="resource4.robot">Resource file</a><br>
    <a href="testSite4.robot">Robot script</a> - This script shows the whole test as one keyword<br>
    <a href="testSite4a.robot">Alternate robot script</a> - This script shows separate keywords for all major test steps and the Test Template coordinating
  </body>
</html>
