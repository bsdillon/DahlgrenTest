<!DOCTYPE html>
<html>
  <head>
    <title>Robot Framework Training</title>
    <link href = "./../../common.css" rel = "stylesheet">
    <script>
    </script>
  </head>
  <body>
    <h2>Robot Framework Training</h2>
    <p>
      This page covers the instructions for setup, development, and use of
      Robot Framework. Robot Framework or RFW is a free set of libraries that
      can be used to enable automatic testing. RFW is flexible and can easily
      incorporate any tool or library through the Python language. In the course
      of events, Dahlgren has developed a set of external files that assist in
      and enhance the experience using RFW. This is the third set of such 
      libraries and thus we refer to it as RFW 3.0.
    </p>
    <p>
      This document is intended to be used as part of a hands on training 
      session and may be self-led. For the complete novice it is suggested
      that you complete the instructions in order moving from configurtion,
      to your first test, etc. until you have used all the RFW 3.0 features.
      Experts may use the table of contents below to find any section of
      interest.
    </p>

    <h3>Table of Contents</h3>
    <ul>
      <li><a href="#configuration">Configuration</a>
        <ul>
          <li><a href="#downloads">Download lists</a></li>
          <li><a href="#operatingsystem">Operating System</a></li>
          <li><a href="#versions">Versions</a></li>
          <li><a href="#packages">Installing RHEL Packages</a></li>
          <li><a href="#pipinstall">Python Pip Installs</a></li>
          <li><a href="#paths">Setting Paths</a></li>
          <li><a href="#validation">System Validation</a></li>
        </ul>
      </li>
      <li><a href="#session1">The Simplest Example</a>
        <ul>
          <li><a href="#session1-instr">Instructions</a></li>
          <li><a href="#session1-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session2">Using Keywords</a>
        <ul>
          <li><a href="#session2-instr">Instructions</a></li>
          <li><a href="#session2-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session3">Data-Driven Testing</a>
        <ul>
          <li><a href="#session3-instr">Instructions</a></li>
          <li><a href="#session3-solut">Solution Files</a></li>
        </ul>
      </li>
    </ul>

      <li>
        <ul>
          <li><a href="#"></a></li>
        </ul>
      </li>

    <a name="configuration"></a><h2>Configuration</h2>
    <a name="downloads"></a>
    <h4>Redhat Distribution</h4>
    <ul>
      <li>Python3X<span class="red"><sup>*</sup></span></li>
      <li>Python3X<span class="red"><sup>*</sup></span>-libs</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-pip</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-setuptools</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-tkinter</li>
      <li>tcl</li>
      <li>tk</li>
      <li>tesseract-devel</li>
      <li>tesseract</li>
      <li>leptonica</li>
      <li>leptonica-devel</li>
      <li>java-XXXX-openjdk-devel</li>
      <span class="red">*</span> - See <a href="#versions">discussion of python version</a>
    </ul>
    <h4>Python Libraries</h4>
    <ul>
      <li>pillow [<a href="https://pypi.org/project/Pillow/#history">link</a>]</li>
      <li>Py4J [<a href="https://pypi.org/project/py4j/">link</a>]</li>
      <li>robotframework [<a href="https://pypi.org/project/robotframework/">link</a>]</li>
    </ul>
    <h4>Other</h4>
    <ul>
      <li><a href="deployment.zip" download target="_blank">RFW 3.0</a></li>
      <li>SikuliX Jar [<a href="https://raiman.github.io/SikuliX1/downloads.html">link</a>]</li>
      <li>Py4J Jar - Downloaded with Py4J python.</li>
    </ul>

    <a name="operatingsystem"></a><h3>Operating System</h3>
    <p>
      RFW 3.0 works on Windows and should be compatible with any operating 
      system. These instructions, however, are written for a Red Hat 
      Enterprise Linux machine. If you are using a different operating 
      system you may have to adapt them for your system.
    </p>

    <a name="versions"></a><h3>Versions</h3>
    <p>
      The download list is very dependent on the version of python selected.
      Robot Framework works with Python 3.6+. The code in RFW 3.0 was written
      for Python 3.10.8. You are free to pick any version of python which your
      site will support subject to those constraints. If you pick a version <em>between</em>
      the two ends you may have to roll back some of the more recent python
      syntax found in the libraries. Whatever version of python you 
      choose, you must use the same version for all RHEL distribution files.
      In these instructions we will simply refer to the selected version as
      python3X.
    </p>
    <p>
      There are two other version issues to consider in these downloads:<br>
      <ul>
        <li>
          There is a <a href="https://pillow.readthedocs.io/en/stable/installation.html">table</a>
          which shows dependencies between python and Pillow. Make sure you 
          install a verison of pillow that works with the selected python3X.
        </li>
        <li>
          SikuliX works only with Java 8+. You may use any version of Java above
          that version.
        </li>
      </ul>
    </p>

    <a name="packages"></a><h3>Installing RHEL Packages</h3>
    <p>
      Each of the RHEL packages must be installed by the root (or SUDO) 
      role using the command <code>yum install <i>package-name</i></code>. It
      is recommended that you install tkinter, pip, tesseract-devel, and java-devel.
      All the rest are installed as dependencies. After installing the packages, 
      find the command for python 3 in your system using <code>which python3</code>
      or you can search the <code>/user/bin/</code> folder. Sometimes the
      system assigns names like python3.X depending on the selected version.
    </p>

    <a name="pipinstall"></a><h3>Python Pip Installs</h3>
    <p>
      If you are attached to the web you can automatically download and install
      python libraries using <code>python3 -m pip install <i>package</i></code>.
      In the case of pillow you can specify the desired version number by adding
      <code>python3 -m pip install pillow==<i>version_number</i></code>. If you 
      are installing offline, you may point to any downloaded library path using
      <code>python3 -m pip install <i>PATH</i></code>.
    </p>

    <a name="paths"></a><h3>Setting Paths</h3>
    <p>
      When the Py4J is pip-installed, it should savea  Java Jar file on your system.
      This is usually found in /usr/share/py4j or /usr/local/share/py4j. Locate
      this Jar file. You will need to add that Jar file and the Sikuli Jar to your
      CLASSPATH variable. This will ensure that they can be found during compilation
      of the Sikuli Entry Point. For similar reasons, you will need to create/update
      the runRobot.bat. This file is found in the RFW 3.0 deployment under RFTest and
      it adds critical python file locations to a the PYTHONPATH and PATH variables.
      The cricial locations are the widgets and OQE folders. 
    </p>
    <p>
      RFW 3.0 is also dependent on a reference to the <em>data folder</em>. This is a
      folder which you can create exclusively for the purpose of recording RFW test
      results. Once you have created the folder, you need to set the full path in 
      several places. Update each of these to match your data folder
    </p>
    <dl>
      <dt><code>deployment/RFTest/validation/test.robot</code></dt>
        <dd>Search for <code>${DATA PATH}</code> and replace the value with your own.</dd>
      <dt><code>deployment/RFTest/RFDemoGUI/demoGUI.html</code></dt>
        <dd>Search for <code>./../../../../RFData</code> and replace with the relative path to your data folder. <span class="red">THERE ARE TWO</span><br><br>
        Please note that this is a "relative" path. So <code>.</code> is the folder with demoGUI.html and <code>./..</code> is one folder up (i.e. RFTest).
        If your data folder is <code>data</code> in the same folder as <code>deployment</code> use:<br>
        <code>./../../data/test.js</code></dd>
    </dl>
    <p>
      You also need to replace the "empirical" path for the RFTest folder.
    </p>
    <dl>
      <dt><code>deployment/RFTest/validation/test.robot</code></dt>
        <dd>Search for <code>gui.Configure</code> and replace the path to RFTest.</dd>
      <dt><code>deployment/RFTest/runrobot.bat</code></dt>
        <dd>Search for <code>testRoot</code> and replace the  path to RFTest.</dd>
    </dl>

    <a name="validation"></a><h3>System Validation</h3>
    <p>
      Under <code>deployment/RFTest</code> there is a validation project that
      touches all the major features and will ensure your system is properly 
      configured. You may run either the windows or linux version of the
      <code>testconfig_<i>OS</i>.bat</code> script. The script should lead you
      through the following automated checks:
    </p>
    <ol>
      <li>Start the Java-Sikuli EntryPoint server.</li>
      <li>Start a test GUI that uses python3X, tkinter, and pillow.</li>
      <li>Run a RFW test that verifies the test GUI and logs data.</li>
    </ol>

    <p>
      After the automatic steps successfully conclude, you may close the 
      open windows and verify the following:
    </p>
    <ol>
      <li>Open the auto-generated report <code>deployment/RFTest/RFDemoGUI/demoGUI.html</code>.
          Click on the first test link and verify the contents "Actual: Everying worked, Expected: Everything worked"</li>
      <li>Open the default log <code>deployment/RFTest/log.html</code> and see all passes
        <ul>
          <li>Expand "Configuration Checks" and locate "Prove it works" and "Document API". Expand the Log just after each line
            <ul>
              <li>Verify "output.py is connected"</li>
              <li>Verify the list of actions for Window[validation]: find, setGroup, ..."</li>
            </ul>
          </li>
          <li>Expand "Test Start" and Log</li>
          <li>Verify "Text read by tesseract: Working"</li>
        </ul>
      </li>
    </ol>
    <p class="blue">Congratulations! Your system is properly configured.</p>

    <a name="session1"></a><h2>The Simplest Example</h2>
    <p>
      The first test case is meant to demonstrate the basics structure of a RF script
      and the use of online documentation. The objectives for this lesson 
      are very simple. Learners will create a minimal viable product (MVP), a term for
      the least amount of infrastructure and code to achieve the goal. In this case
      the MVP is a working RFW test which purposely fails. The learner launches the 
      test and verifies that the correct behavior.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session1-instr"></a>
      <li>
        Create a new folder under <code>deployment/RFTest/examples</code>. Open a 
        simple text editor and save a new file as <code>rfw1.robot</code> in that folder. 
        Add the following required elements to the robot script.<br>
          <code>
*** Settings ***<br>
*** Variables ***<br>
*** Test Cases ***<br>
*** Keywords ***
          </code></li>
      <li>Settings is where other libraries and extensions can be added to your test.
      Later we will use this section to bring in reusable test components. In this case
      we will import one of the standard RFW libraries. Add this line after settings.<br>
          <code>
*** Settings ***<br>
Library&nbsp;&nbsp;&nbsp;String
          </code>
<br><br>
      <span class="red">WARNING</span> Robot syntax requires a minimum of 3 spaces between 
      "keywords" and "parameters". We will get a handle on the vocabulary later, but in
      the previous line "Library" is a keyword and "String" is the parameter. If you only
      put one space (e.g. "Library String") that is not the same thing and you will have
      an error in your test script.</li>
      <li>Variables is a place to declare any data values you want to track during the test.
      RFW allows you to define variables within a keyword, for a test, or for a whole suite
      of tests. In this case we will use a variable to enter a medium length word. You might
      pick your favorite US state. Also save a numeric value.<br>
          <code>
*** Variables ***<br>
${state}&nbsp;&nbsp;&nbsp;Virginia<br>
${num}&nbsp;&nbsp;&nbsp;${3}
          </code>
<br><br>
      In this case <code>${state}</code> is the name of the variable. You can think of it as 
      a box to hold data. Here '$' indicates this variable contains a single variable. There 
      is a <a href="https://robocorp.com/docs/languages-and-frameworks/robot-framework/cheat-sheet">useful reference</a>
      demonstrating all the variable types and syntax.
<br><br>
      In most computer languages all numbers are counted from zero and RFW is no exception
      In this test we will try to find the 3rd character in the state name. Note that because
      we start counting at zero, the 0th character is 'V'. Following this logic, the 3rd
      character is 'g'. RFW does recognize different data types but most data is considered 
      to be text by default. Thus the word Virginia is text without any fancy wrapper. 
      This will be useful later. Unfortunately, the simple numeric value 3 must be wrapped 
      <code>${3}</code> to force it NOT to be text.
      </li>
      <li>Test cases are the actual test script and we will spend more time on that section
      shortly. For now, let's create a simple test case that barely does anything.<br>
          <code>
*** Test Cases ***<br>
Dummy Case<br>
&nbsp;&nbsp;&nbsp;Call this
          </code>
<br><br>
      The anatomy of a test case is simple. Each test case gets a name which will appear in
      the pass/fail report. After than RFW uses white space (i.e. the same 3 required spaces)
      to indent the contents of the test case. Thus <code>Dummy Case</code> is the name of
      the test case and <code>Call this</code> is part of its contents. Whatever its meaning
      <code>Call this</code> must pass for the Dummy Case to pass.
      </li>
      <li>Keywords are the basic unit of a RFW script. In later lessons you will learn how to
      create your own library of keywords for reuse in larger and more complex test scripts.
      For now we will create the <code>Call this</code> keyword which was suggested in our test
      case.<br>
          <code>
*** Keywords ***<br>
Call this<br>
&nbsp;&nbsp;&nbsp;Fail&nbsp;&nbsp;&nbsp;Hello World
          </code>
<br><br>
      You should recognize that the anatomy of a keyword is very similar to a test case. 
      <code>Call this</code> is the name of the keyword and the contents of the keyword 
      are indented. In this case, <code>Fail</code> is another keyword that comes from 
      the RFW <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html">BuiltIn</a>
      library. That library is NOT found in settings and can be assumed in all your tests.
<br><br>
      Let's explore the two libraries that we are using in this test. Here the <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html">BuiltIn</a>
      keywords can be reviewed and we can find the <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Fail">Fail</a> keyword in particular.
      We can use a similar set of links to examine the <a href="https://robotframework.org/robotframework/latest/libraries/String.html">String</a>
      library and the <a href="https://robotframework.org/robotframework/latest/libraries/String.html#Split%20String%20To%20Characters">Split String To Characters</a>
      keyword we will use in this test. The <a href="https://robotframework.org/">Robot Framework Foundation</a>
      owns RFW and maintains its extensive documentation and libraries. Among their offerings
      are far more complete training resources. Perhaps for further reading. Our purpose in
      visiting these libraries is to demonstrate the means at your disposal to find out more
      about what keywords are out there and how they are used. Take a few minutes to look at
      the examples shown in each case.
<br><br>
      </li>
      <li>
        You have created a test! Now we are going to run it and show the features of RFW.
        Open a terminal and navigate to the RFTest folder. Usually, you will run all your
        RFW trests from this location. We do this with <code>runRobot.bat</code> which sets
        up relative paths for all the RFW3 libraries. The command is <code>./runRobot.bat ./example/yourfolder/rfw1.robot</code>.
        The run should produce something like this.<br><img src="commandline.png">
<br><br>
        It is traditional that any new programmer should start with Hello World, but it is
        unusual to achieve that goal by failing a test. Note here that the name of the test
        case (i.e. "Dummy Case") shows up in the test and that it is marked as failed. This
        is the only test case in the test, however, you could add another and each test 
        case would have its own line in this report. Note also that 1 test ran, 0 passed,
        and 1 failed. These are the sorts of metrics that RFW can take as part of the 
        <em>framework</em> and without any effort on your part.<br><img src="report.png">
<br><br>
        The default log is another useful product automatically generated by RFW. The report
        is generated as an HTML file in RFTest and shows the test steps as a hierarchy. In 
        this way the test <code>Rfw1</code> contains the case <code>Dummy Case</code> which 
        calls the keyword <code>Call this</code> which calls the keyword <code>Fail</code> 
        and produces the message "Hello World". In this hierarchical view you may catch your
        first glimpse of the structure of Robot Framework. The redundant red markers leads
        the tester to the point of failure and in future cases may be contrasted with green
        markers that are collapsed by default--after all, nothing broke there.
      </li>
    </ol>
    <a name="session1-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw1.robot" download target="_blank">Robot script</a><br>

    <a name="session2"></a><h2>Using Keywords</h2>
    <p>
      In the previous test we created both a test case and a keyword without
      making much distinction. In this test we will flesh out the concept of
      a keyword and the distinction between a test case and a keyword. The 
      learner will create a test with multiple cases and a reusable keyword.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session2-instr"></a>
      <li>
        Start by downloading and opening the solution from the previous lesson.
        Resave it as rfw2.robot in the same folder.
      </li>
      <li>
        We will begin by building one real test. You can delete the <code>Dummy Case</code>
        and the <code>Call this</code> keyword for good measure. We will begin
        by creating a new test case. Run the test as before.<br>
          <code>
*** Test Cases ***<br>
Read Character<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state
          </code>
<br><br>
        You will notice right away that this time the command line shows a green pass for
        the test case. This is the default position on all tests. Unless something happens
        to halt execution (a bug or complete crash), your test will pass. In the previous
        lesson we intentionally <code>Fail</code> the test which is sometimes an important
        outcome. Open the default log and full expand to read the final output <code>Virginia is my state</code>.
      </li>
      <li>
        Let's expand the test to search for the 3rd character as previously discussed. Here
        we will use the <code>Split String To Characters</code> keyword to get a list. In
        RFW a list is a variable with an ordered group of values and is denoted with a '@'
        instead of '$'. Note also that we will use the <code>${num}</code> to identify one
        specific character. The square bracket syntax <code>[ ]</code> indicates that we only
        want the list value at that index. Run the text, read the log, and verify it found 'g'.<br>
          <code>
*** Test Cases ***<br>
Read Character<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${state}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;The character is ${characters}[${num}]
          </code>
<br><br>
        At this point it is worth noting something for the developers. Normally, some value 
        or even some text would have to be aggregated before it could be printed like this.
        The text "The Character is" is somehow automatically linked with the return value 'g'.
        How? Under the hood, RFW uses python functions and this entire string will be seen
        as plain text in Python. In the transition between <code>${characters}[${num}]</code>
        and text, the value of the RFW variable is substituted. The aggregate is simply interpreted
        as text. This instance is making valuable use of the substitution step, but the default
        text interpretation is also trouble. You might pass what you think is <code>1</code>
        but the python gets <code>'1'</code>. <span class="red">BEWARE!</span> We'll talk
        again soon.
      </li>
      <li>
        Now we have a test case that verifies one aspect of the state and does nothing more.
        It is a one-trick pony. To accomplish more with a test, we want to move the <em>functionality</em>
        from the test case into a new keyword. This is called <em>refactoring</em> and more
        specifically <a href="https://refactoring.guru/extract-method">Extract Function</a>.
        The goal of refactoring is to maintain the same function while changing the form of
        the script and in the process make it easier to work with. Because we want to verify
        the same functionality we will build a second test case and then gradually add features.
        For right now copy and paste the existing test case. Rename the new case however you
        like. After each small step you can instantly rerun the test to verify that the 
        function remains the same.<br>
          <code>
*** Test Cases ***<br>
Read Character<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${state}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;The character is ${characters}[${num}]<br>
<br>
Read Character 2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${state}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;The character is ${characters}[${num}]
          </code>
<br><br>
        Once you rerun the test you will see that there are now TWO test cases and both 
        pass. In the log too there are TWO test cases. A quick check shows that BOTH cases
        have the same behavior and results.
      </li>
      <li>
        Next we will create a keyword to <code>Find Nth Character</code>. It won't do
        anything yet, but we'll have the right format. In this structure we can see
        two characteristics of a Keyword that are NOT part of test cases: parameters 
        and return statements. As previously discussed, parameters are separated from
        a keyword by the requisite 3 spaces. A <a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#using-arguments">parameter</a> is used to give the keyword
        information it needs to do its job. RFW uses the synonym 'argument' in its
        syntax. This keyword has two arguments/parameters (<code>${text}</code> and 
        <code>${n}</code>). Note that the <code>[ARGUMENTS]</code> always imeadiately 
        follow the keyword name and that each argument/parameter is separated by the 
        usual spaces.<br>
          <code>
*** Keywords ***<br>
Find Nth Character<br>
&nbsp;&nbsp;&nbsp;[ARGUMENTS]&nbsp;&nbsp;&nbsp;${text}&nbsp;&nbsp;&nbsp;${n}<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${text}
&nbsp;&nbsp;&nbsp;[RETURN]&nbsp;&nbsp;&nbsp;${characters}[${n}]
          </code>
<br><br>
        The return statement is the means of giving a value back from a keyword. In
        this example we are going to find the Nth character and then we have to give
        it back. The Nth character is returned from the keyword. This could be returned
        to a test or another keyword--whatever called <code>Find Nth Character</code>.
        That kind of flexibility means that this keyword can be used and reused in 
        different settings.
<br><br>
        Few keywords are of much value without parameters and return statements. Maybe
        the keyword is smart enough to find the data it needs elsewhere (e.g. reading
        something off the screen). Maybe it can take some action that is more important
        than returning a value (e.g. push a button). Whatever the case, flexible and 
        reusable keywords are easiest to make when you have parameters that allow input
        to vary and a return statement that shares the result with the calling script.
<br><br>
        <span class="red">NOTE</span> the changes in this step will have NO effect
        because the new keyword isn't called from anywhere in the test cases. We have
        extracted the functionality, but not used it.
      </li>
      <li>
        In this last step we will change the second test case to use the new keyword.
        Because we have already extracted the functionality into the keyword, we only
        have to figure out how to work with that keyword. In this case we pass the state
        and the number to the keyword as parameters. Parameters have to be in the same
        order, but the names of the parameters in the keyword (i.e. <code>${text}</code> 
        and <code>${n}</code>) don't have to match the values we pass (i.e. <code>${state}</code>
        and <code>${num}</code>). Whatever value is returned will be stored in a temporary
        variable <code>${a}</code>. Afterward, we log that text. Run the test again and see
        that all of our changes have not broken the function. In the mean time, we have 
        made a new, reusable keyword that will help with our future testing. That's refactoring.
          <code>
Read Character 2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;${num}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}
          </code>
      </li>
      <li>
        Now that we have a reusable keyword, it's much easier to create a series of 
        test cases that use a set of parameters instead of copied code. Let's test 
        this out and use the <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal">Should Be Equal</a>
        keyword. You can copy these test cases and build more based on different
        parameters. Try to make 10 or more. Test them and see the various pass/fail
        answers per case.<br>
          <code>
*** Test Cases ***<br>
Read Character 1<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;${num}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;g<br>
<br>
Read Character 2<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;g<br>
<br>
Read Character 3<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;${num}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;i<br>
<br>
Read Character 4<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;r<br>
          </code>
<img src="commandline2.png">
      </li>
    </ol>

    <a name="session2-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw2.robot" download target="_blank">Robot script</a><br>

    <a name="session3"></a><h2>Data-Driven Testing</h2>
    <p>
      Starting with this lesson the instructions will focus less on line-by-line
      code instructions and more on guidance. Training wheels are off, but we aren't
      letting go just yet. This lesson also introduces Data-Driven Testing or DDT
      which is a testing paradigm where one test script is enabled by multiple 
      test <em>cases</em> in the form of parameters. The learner will convert the
      very duplicative last lesson into a DDT paradigm which makes more sense.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session3-instr"></a>
      <li>
        Start by downloading and opening the solution from the previous lesson.
        Resave it as rfw3.robot in the same folder.
      </li>
      <li>
        If you look at the last lesson you will see that the test cases are
        very repetitive. This is not at all unusual. A lot of tests suffer
        from a need to test variations on a theme. Start by creating a new
        keyword that would do the same job with parameters. Create parameters
        for the text, the number, and the expected value.
      </li>
      <li>
        For DDT, we need to identify one keyword, the one we just created
        which will act as the <code>Test Template</code>. In other words,
        this new keyword is the test script and we will activate it with
        different parameters for each test case. We identify the Test 
        Template in the settings.
          <code>
*** Settings ***<br>
Library&nbsp;&nbsp;&nbsp;String<br>
Test Template&nbsp;&nbsp;&nbsp;Read Character
          </code>
<br><br>
        For DDT in RFW the Test Template is <em>required</em>, but there are four
        other specialized keywords that can be defined for a single DDT test. These
        are not required, but may be a good idea. As shown in this image, the 
        designated keywords are executed in a fixed order. While only five keywords
        are used in DDT, you are not limited. Remember that a keyword can call
        another keyword. With these five keywords we are defining five "jumping off"
        points which can contain as much or as little as we want. Which can call
        other keywords if desired.<br>
        <img src="testLoop.png">
<br>
        <code>Suite Setup</code> is called 
        before everything else in order to configure the system for test. This 
        process brings up everything in a default state and may pull up auxiliary
        elements (e.g. the Java-Sikuli server). At the very end of the test is 
        <code>Suite Teardown</code> which performs a complementary service,
        closing things down, shutting off auxiliary services, and posting final 
        data. At the individual test case level there are similar setup and teardown
        keywords. These are more likely used to configure the parameters for a
        specific test (e.g. "Is the light switch currently ON before we start")
        and restoration to the safe, default state after a test. The <code>Test Teardown</code>
        is especially important if the next test will depend on starting in a
        safe space. Are all my services still up? Did I remember to turn off the
        lights? In this test we will only use the <code>Test Template</code> but
        we will see the others soon.
      </li>
      <li>
        Now it's time to address the test cases themselves. In a DDT configuration 
        RFW still has test cases, but it represents each case as just one line of 
        parameters. Based on the test cases demonstrated in the last lesson, these
        are the four test cases one might use. Note that each line has a test name
        which can be quite informative. After that each paramter can be either a 
        value or one of the variables. In this case I added a fourth variable which
        says if I expected to find the matching value. It's counter intuitive, but
        if the test <em>doesn't</em> find a match and I didn't <em>expect</em> to 
        get a match, that's still a pass. We will deal with that in a minute. Use
        your own test cases from lesson 2 to create more test cases following this
        pattern.<br>
          <code>
*** Test Cases ***&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;&nbsp;Char&nbsp;&nbsp;&nbsp;&nbsp;Match<br>
Find g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
No find g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False<br>
No find r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False<br>
Find r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True
          </code>
<br><br>
        You may have noticed that the parameters of the test case are all aligned vertically.
        This was intentionally done with a combination of tabs and spaces (always at least one
        tab or 3 spaces). We have found that aligning your paramters allows you to
        directly compare your test cases and identify problems. On the Test Cases 
        line there are even names for the parameters. They have no effect on RFW
        but are also helpful to the test writer. It's easier to remember what 'g'
        or 'r' means if you put a label on it.
      </li>
      <li>
        Let's add that fourth parameter to our Test Template keyword and decide how
        to handle it. In this case we want to either use <code>Should Be Equal</code>
        or the similarly obvious <code>Should Not Be Equal</code>. And we want our new
        parameter to tell us which to use. The natural way to handle this is to 
        <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Run%20Keyword%20If">Run Keyword If</a>
        there is a match or not a match. Because <code>Run Keyword If</code> has a built
        in <code>ELSE</code> feature, we can include both actions on the same line.
        Work on your own to build a simple If-Else using the Should and Should Not checks.
        Remember that you can run your test multiple times as you think you have 
        reached incremental stopping points.
      </li>
      <li>
        There is nothing holding us to the state and number we chose. We are free 
        to create entirely new cases. You can add more variables to create standard
        components or you may enter any text you want in any individual test case.
        Experiment and rerun your tests periodically. Be sure to look at the default
        log as well.
      </li>
    </ol>
    <a name="session3-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw3.robot" download target="_blank">Robot script</a><br>



    <a name="session2"></a><h2>Using Keywords</h2>
    <p>
    </p>

    <h3>Instructions</h3>
    <ol><a name="session2-instr"></a>
      <li>
      </li>
    </ol>
    <a name="session2-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw1.robot" download target="_blank">Robot script</a><br>
  </body>
</html>
