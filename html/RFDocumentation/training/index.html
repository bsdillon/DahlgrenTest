<!DOCTYPE html>
<html>
  <head>
    <title>Robot Framework Training</title>
    <link href = "./../../common.css" rel = "stylesheet">
    <script>
    </script>
  </head>
  <body>
    <h2>Robot Framework Training</h2>
    <p>
      This page covers the instructions for setup, development, and use of
      Robot Framework. Robot Framework or RFW is a free set of libraries that
      can be used to enable automatic testing. RFW is flexible and can easily
      incorporate any tool or library through the Python language. In the course
      of events, Dahlgren has developed a set of external files that assist in
      and enhance the experience using RFW. This is the third set of such 
      libraries and thus we refer to it as RFW 3.0.<br><br>
      If you would like to see the <a href=".\one\index.html">original RFW training</a>, 
      use this link.
    </p>
    <p>
      This document is intended to be used as part of a hands on training 
      session and may be self-led. For the complete novice it is suggested
      that you complete the instructions in order moving from configurtion,
      to your first test, etc. until you have used all the RFW 3.0 features.
      Experts may use the table of contents below to find any section of
      interest.
    </p>

    <h3>Table of Contents</h3>
    <ul>
      <li><a href="#configuration">Configuration</a>
        <ul>
          <li><a href="#downloads">Download lists</a></li>
          <li><a href="#operatingsystem">Operating System</a></li>
          <li><a href="#versions">Versions</a></li>
          <li><a href="#packages">Installing RHEL Packages</a></li>
          <li><a href="#pipinstall">Python Pip Installs</a></li>
          <li><a href="#paths">Setting Paths</a></li>
          <li><a href="#validation">System Validation</a></li>
        </ul>
      </li>
      <li><a href="#session1">The Simplest Example</a>
        <ul>
          <li><a href="#session1-instr">Instructions</a></li>
          <li><a href="#session1-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session2">Using Keywords</a>
        <ul>
          <li><a href="#session2-instr">Instructions</a></li>
          <li><a href="#session2-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session3">Data-Driven Testing</a>
        <ul>
          <li><a href="#session3-instr">Instructions</a></li>
          <li><a href="#session3-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session4">Working With A GUI</a>
        <ul>
          <li><a href="#session4-instr">Instructions</a></li>
          <li><a href="#session4-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session5">Recording the Test</a>
        <ul>
          <li><a href="#session5-instr">Instructions</a></li>
          <li><a href="#session5-solut">Solution Files</a></li>
        </ul>
      </li>
      <li><a href="#session6">Resource Files</a>
        <ul>
          <li><a href="#session6-instr">Instructions</a></li>
          <li><a href="#session6-solut">Solution Files</a></li>
        </ul>
      </li>
    </ul>

    <a name="configuration"></a><h2>Configuration</h2>
    <a name="downloads"></a>
    <h4>Redhat Distribution</h4>
      <span class="red">NOTE</span> After some study, the list below is NOT sufficient
      for installation in a RHEL environment. You will need several dozen more 
      libraries. Therefore, it is recommended that any offline installation be
      facilitated by an offline RHEL repository from your administrator.
    <ul>
      <li>Python3X<span class="red"><sup>*</sup></span></li>
      <li>Python3X<span class="red"><sup>*</sup></span>-libs</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-pip</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-setuptools</li>
      <li>Python3X<span class="red"><sup>*</sup></span>-tkinter</li>
      <li>tcl</li>
      <li>tk</li>
      <li>tesseract-devel</li>
      <li>tesseract</li>
      <li>leptonica</li>
      <li>leptonica-devel</li>
      <li>java-XXXX-openjdk-devel</li>
      <span class="red">*</span> - See <a href="#versions">discussion of python version</a>
    </ul>
    <h4>Python Libraries</h4>
    <ul>
      <li>pillow [<a href="https://pypi.org/project/Pillow/#history">link</a>]</li>
      <li>Py4J [<a href="https://pypi.org/project/py4j/">link</a>]</li>
      <li>pytesseract [<a href="https://pypi.org/project/pytesseract/">link</a>]</li>
      <li>robotframework [<a href="https://pypi.org/project/robotframework/">link</a>]</li>
    </ul>
    <h4>Other</h4>
    <ul>
      <li><a href="deployment.zip" download target="_blank">RFW 3.0</a></li>
      <li>SikuliX Jar [<a href="https://raiman.github.io/SikuliX1/downloads.html">link</a>]</li>
      <li>Py4J Jar - Downloaded with Py4J python.</li>
    </ul>

    <a name="operatingsystem"></a><h3>Operating System</h3>
    <p>
      RFW 3.0 works on Windows and should be compatible with any operating 
      system. These instructions, however, are written for a Red Hat 
      Enterprise Linux machine. If you are using a different operating 
      system you may have to adapt them for your system.
    </p>

    <a name="versions"></a><h3>Versions</h3>
    <p>
      The download list is very dependent on the version of python selected.
      Robot Framework works with Python 3.6+. The code in RFW 3.0 was written
      for Python 3.10.8. You are free to pick any version of python which your
      site will support subject to those constraints. If you pick a version <em>between</em>
      the two ends you may have to roll back some of the more recent python
      syntax found in the libraries. Whatever version of python you 
      choose, you must use the same version for all RHEL distribution files.
      In these instructions we will simply refer to the selected version as
      python3X.
    </p>
    <p>
      There are two other version issues to consider in these downloads:<br>
      <ul>
        <li>
          There is a <a href="https://pillow.readthedocs.io/en/stable/installation.html">table</a>
          which shows dependencies between python and Pillow. Make sure you 
          install a verison of pillow that works with the selected python3X.
        </li>
        <li>
          SikuliX works only with Java 8+. You may use any version of Java above
          that version.
        </li>
      </ul>
    </p>

    <a name="packages"></a><h3>Installing RHEL Packages</h3>
    <p>
      Each of the RHEL packages must be installed by the root (or SUDO) 
      role using the command <code>yum install <i>package-name</i></code>. It
      is recommended that you install tkinter, pip, tesseract-devel, and java-devel.
      All the rest are installed as dependencies. After installing the packages, 
      find the command for python 3 in your system using <code>which python3</code>
      or you can search the <code>/user/bin/</code> folder. Sometimes the
      system assigns names like python3.X depending on the selected version.
    </p>

    <a name="pipinstall"></a><h3>Python Pip Installs</h3>
    <p>
      If you are attached to the web you can automatically download and install
      python libraries using <code>python3 -m pip install <i>package</i></code>.
      In the case of pillow you can specify the desired version number by adding
      <code>python3 -m pip install pillow==<i>version_number</i></code>. If you 
      are installing offline, you may point to any downloaded library path using
      <code>python3 -m pip install <i>PATH</i></code>.
    </p>

    <a name="paths"></a><h3>Setting Paths</h3>
    <p>
      When the Py4J is pip-installed, it should savea  Java Jar file on your system.
      This is usually found in /usr/share/py4j or /usr/local/share/py4j. Locate
      this Jar file. You will need to add that Jar file and the Sikuli Jar to your
      CLASSPATH variable. This will ensure that they can be found during compilation
      of the Sikuli Entry Point. For similar reasons, you will need to create/update
      the runRobot.bat. This file is found in the RFW 3.0 deployment under RFTest and
      it adds critical python file locations to a the PYTHONPATH and PATH variables.
      The cricial locations are the widgets and OQE folders. 
    </p>
    <p>
      RFW 3.0 is also dependent on a reference to the <em>data folder</em>. This is a
      folder which you can create exclusively for the purpose of recording RFW test
      results. Once you have created the folder, you need to set the full path in 
      several places. Update each of these to match your data folder
    </p>
    <dl>
      <dt><code>deployment/RFTest/validation/test.robot</code></dt>
        <dd>Search for <code>${DATA PATH}</code> and replace the value with your own.</dd>
      <dt><code>deployment/RFTest/RFDemoGUI/demoGUI.html</code></dt>
        <dd>Search for <code>./../../../../RFData</code> and replace with the relative path to your data folder. <span class="red">THERE ARE TWO</span><br><br>
        Please note that this is a "relative" path. So <code>.</code> is the folder with demoGUI.html and <code>./..</code> is one folder up (i.e. RFTest).
        If your data folder is <code>data</code> in the same folder as <code>deployment</code> use:<br>
        <code>./../../data/test.js</code></dd>
    </dl>
    <p>
      You also need to replace the "empirical" path for the RFTest folder.
    </p>
    <dl>
      <dt><code>deployment/RFTest/validation/test.robot</code></dt>
        <dd>Search for <code>gui.Configure</code> and replace the path to RFTest.</dd>
      <dt><code>deployment/RFTest/runrobot.bat</code></dt>
        <dd>Search for <code>testRoot</code> and replace the  path to RFTest.</dd>
    </dl>

    <a name="validation"></a><h3>System Validation</h3>
    <p>
      Under <code>deployment/RFTest</code> there is a validation project that
      touches all the major features and will ensure your system is properly 
      configured. You may run either the windows or linux version of the
      <code>testconfig_<i>OS</i>.bat</code> script. The script should lead you
      through the following automated checks:
    </p>
    <ol>
      <li>Start the Java-Sikuli EntryPoint server.</li>
      <li>Start a test GUI that uses python3X, tkinter, and pillow.</li>
      <li>Run a RFW test that verifies the test GUI and logs data.</li>
    </ol>

    <p>
      After the automatic steps successfully conclude, you may close the 
      open windows and verify the following:
    </p>
    <ol>
      <li>Open the auto-generated report <code>deployment/RFTest/RFDemoGUI/demoGUI.html</code>.
          Click on the first test link and verify the contents "Actual: Everying worked, Expected: Everything worked"</li>
      <li>Open the default log <code>deployment/RFTest/log.html</code> and see all passes
        <ul>
          <li>Expand "Configuration Checks" and locate "Prove it works" and "Document API". Expand the Log just after each line
            <ul>
              <li>Verify "output.py is connected"</li>
              <li>Verify the list of actions for Window[validation]: find, setGroup, ..."</li>
            </ul>
          </li>
          <li>Expand "Test Start" and Log</li>
          <li>Verify "Text read by tesseract: Working"</li>
        </ul>
      </li>
    </ol>
    <p class="blue">Congratulations! Your system is properly configured.</p>

    <a name="session1"></a><h2>The Simplest Example</h2>
    <p>
      The first test case is meant to demonstrate the basics structure of a RF script
      and the use of online documentation. The objectives for this lesson 
      are very simple. Learners will create a minimal viable product (MVP), a term for
      the least amount of infrastructure and code to achieve the goal. In this case
      the MVP is a working RFW test which purposely fails. The learner launches the 
      test and verifies that the correct behavior.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session1-instr"></a>
      <li>
        Create a new folder under <code>deployment/RFTest/examples</code>. Open a 
        simple text editor and save a new file as <code>rfw1.robot</code> in that folder. 
        Add the following required elements to the robot script.<br>
          <code>
*** Settings ***<br>
*** Variables ***<br>
*** Test Cases ***<br>
*** Keywords ***
          </code></li>
      <li>Settings is where other libraries and extensions can be added to your test.
      Later we will use this section to bring in reusable test components. In this case
      we will import one of the standard RFW libraries. Add this line after settings.<br>
          <code>
*** Settings ***<br>
Library&nbsp;&nbsp;&nbsp;String
          </code>
<br><br>
      <span class="red">WARNING</span> Robot syntax requires a minimum of 3 spaces between 
      "keywords" and "parameters". We will get a handle on the vocabulary later, but in
      the previous line "Library" is a keyword and "String" is the parameter. If you only
      put one space (e.g. "Library String") that is not the same thing and you will have
      an error in your test script.</li>
      <li>Variables is a place to declare any data values you want to track during the test.
      RFW allows you to define variables within a keyword, for a test, or for a whole suite
      of tests. In this case we will use a variable to enter a medium length word. You might
      pick your favorite US state. Also save a numeric value.<br>
          <code>
*** Variables ***<br>
${state}&nbsp;&nbsp;&nbsp;Virginia<br>
${num}&nbsp;&nbsp;&nbsp;${3}
          </code>
<br><br>
      In this case <code>${state}</code> is the name of the variable. You can think of it as 
      a box to hold data. Here '$' indicates this variable contains a single variable. There 
      is a <a href="https://robocorp.com/docs/languages-and-frameworks/robot-framework/cheat-sheet">useful reference</a>
      demonstrating all the variable types and syntax.
<br><br>
      In most computer languages all numbers are counted from zero and RFW is no exception
      In this test we will try to find the 3rd character in the state name. Note that because
      we start counting at zero, the 0th character is 'V'. Following this logic, the 3rd
      character is 'g'. RFW does recognize different data types but most data is considered 
      to be text by default. Thus the word Virginia is text without any fancy wrapper. 
      This will be useful later. Unfortunately, the simple numeric value 3 must be wrapped 
      <code>${3}</code> to force it NOT to be text.
      </li>
      <li>Test cases are the actual test script and we will spend more time on that section
      shortly. For now, let's create a simple test case that barely does anything.<br>
          <code>
*** Test Cases ***<br>
Dummy Case<br>
&nbsp;&nbsp;&nbsp;Call this
          </code>
<br><br>
      The anatomy of a test case is simple. Each test case gets a name which will appear in
      the pass/fail report. After than RFW uses white space (i.e. the same 3 required spaces)
      to indent the contents of the test case. Thus <code>Dummy Case</code> is the name of
      the test case and <code>Call this</code> is part of its contents. Whatever its meaning
      <code>Call this</code> must pass for the Dummy Case to pass.
      </li>
      <li>Keywords are the basic unit of a RFW script. In later lessons you will learn how to
      create your own library of keywords for reuse in larger and more complex test scripts.
      For now we will create the <code>Call this</code> keyword which was suggested in our test
      case.<br>
          <code>
*** Keywords ***<br>
Call this<br>
&nbsp;&nbsp;&nbsp;Fail&nbsp;&nbsp;&nbsp;Hello World
          </code>
<br><br>
      You should recognize that the anatomy of a keyword is very similar to a test case. 
      <code>Call this</code> is the name of the keyword and the contents of the keyword 
      are indented. In this case, <code>Fail</code> is another keyword that comes from 
      the RFW <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html">BuiltIn</a>
      library. That library is NOT found in settings and can be assumed in all your tests.
<br><br>
      Let's explore the two libraries that we are using in this test. Here the <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html">BuiltIn</a>
      keywords can be reviewed and we can find the <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Fail">Fail</a> keyword in particular.
      We can use a similar set of links to examine the <a href="https://robotframework.org/robotframework/latest/libraries/String.html">String</a>
      library and the <a href="https://robotframework.org/robotframework/latest/libraries/String.html#Split%20String%20To%20Characters">Split String To Characters</a>
      keyword we will use in this test. The <a href="https://robotframework.org/">Robot Framework Foundation</a>
      owns RFW and maintains its extensive documentation and libraries. Among their offerings
      are far more complete training resources. Perhaps for further reading. Our purpose in
      visiting these libraries is to demonstrate the means at your disposal to find out more
      about what keywords are out there and how they are used. Take a few minutes to look at
      the examples shown in each case.
<br><br>
      </li>
      <li>
        You have created a test! Now we are going to run it and show the features of RFW.
        Open a terminal and navigate to the RFTest folder. Usually, you will run all your
        RFW trests from this location. We do this with <code>runRobot.bat</code> which sets
        up relative paths for all the RFW3 libraries. The command is <code>./runRobot.bat ./example/yourfolder/rfw1.robot</code>.
        The run should produce something like this.<br><img src="commandline.png">
<br><br>
        It is traditional that any new programmer should start with Hello World, but it is
        unusual to achieve that goal by failing a test. Note here that the name of the test
        case (i.e. "Dummy Case") shows up in the test and that it is marked as failed. This
        is the only test case in the test, however, you could add another and each test 
        case would have its own line in this report. Note also that 1 test ran, 0 passed,
        and 1 failed. These are the sorts of metrics that RFW can take as part of the 
        <em>framework</em> and without any effort on your part.<br><img src="report.png">
<br><br>
        The default log is another useful product automatically generated by RFW. The report
        is generated as an HTML file in RFTest and shows the test steps as a hierarchy. In 
        this way the test <code>Rfw1</code> contains the case <code>Dummy Case</code> which 
        calls the keyword <code>Call this</code> which calls the keyword <code>Fail</code> 
        and produces the message "Hello World". In this hierarchical view you may catch your
        first glimpse of the structure of Robot Framework. The redundant red markers leads
        the tester to the point of failure and in future cases may be contrasted with green
        markers that are collapsed by default--after all, nothing broke there.
      </li>
    </ol>
    <a name="session1-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw1.robot" download target="_blank">Robot script</a><br>

    <a name="session2"></a><h2>Using Keywords</h2>
    <p>
      In the previous test we created both a test case and a keyword without
      making much distinction. In this test we will flesh out the concept of
      a keyword and the distinction between a test case and a keyword. The 
      learner will create a test with multiple cases and a reusable keyword.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session2-instr"></a>
      <li>
        Start by downloading and opening the solution from the previous lesson.
        Resave it as rfw2.robot in the same folder.
      </li>
      <li>
        We will begin by building one real test. You can delete the <code>Dummy Case</code>
        and the <code>Call this</code> keyword for good measure. We will begin
        by creating a new test case. Run the test as before.<br>
          <code>
*** Test Cases ***<br>
Read Character<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state
          </code>
<br><br>
        You will notice right away that this time the command line shows a green pass for
        the test case. This is the default position on all tests. Unless something happens
        to halt execution (a bug or complete crash), your test will pass. In the previous
        lesson we intentionally <code>Fail</code> the test which is sometimes an important
        outcome. Open the default log and full expand to read the final output <code>Virginia is my state</code>.
      </li>
      <li>
        Let's expand the test to search for the 3rd character as previously discussed. Here
        we will use the <code>Split String To Characters</code> keyword to get a list. In
        RFW a list is a variable with an ordered group of values and is denoted with a '@'
        instead of '$'. Note also that we will use the <code>${num}</code> to identify one
        specific character. The square bracket syntax <code>[ ]</code> indicates that we only
        want the list value at that index. Run the text, read the log, and verify it found 'g'.<br>
          <code>
*** Test Cases ***<br>
Read Character<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${state}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;The character is ${characters}[${num}]
          </code>
<br><br>
        At this point it is worth noting something for the developers. Normally, some value 
        or even some text would have to be aggregated before it could be printed like this.
        The text "The Character is" is somehow automatically linked with the return value 'g'.
        How? Under the hood, RFW uses python functions and this entire string will be seen
        as plain text in Python. In the transition between <code>${characters}[${num}]</code>
        and text, the value of the RFW variable is substituted. The aggregate is simply interpreted
        as text. This instance is making valuable use of the substitution step, but the default
        text interpretation is also trouble. You might pass what you think is <code>1</code>
        but the python gets <code>'1'</code>. <span class="red">BEWARE!</span> We'll talk
        again soon.
      </li>
      <li>
        Now we have a test case that verifies one aspect of the state and does nothing more.
        It is a one-trick pony. To accomplish more with a test, we want to move the <em>functionality</em>
        from the test case into a new keyword. This is called <em>refactoring</em> and more
        specifically <a href="https://refactoring.guru/extract-method">Extract Function</a>.
        The goal of refactoring is to maintain the same function while changing the form of
        the script and in the process make it easier to work with. Because we want to verify
        the same functionality we will build a second test case and then gradually add features.
        For right now copy and paste the existing test case. Rename the new case however you
        like. After each small step you can instantly rerun the test to verify that the 
        function remains the same.<br>
          <code>
*** Test Cases ***<br>
Read Character<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${state}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;The character is ${characters}[${num}]<br>
<br>
Read Character 2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${state}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;The character is ${characters}[${num}]
          </code>
<br><br>
        Once you rerun the test you will see that there are now TWO test cases and both 
        pass. In the log too there are TWO test cases. A quick check shows that BOTH cases
        have the same behavior and results.
      </li>
      <li>
        Next we will create a keyword to <code>Find Nth Character</code>. It won't do
        anything yet, but we'll have the right format. In this structure we can see
        two characteristics of a Keyword that are NOT part of test cases: parameters 
        and return statements. As previously discussed, parameters are separated from
        a keyword by the requisite 3 spaces. A <a href="https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#using-arguments">parameter</a> is used to give the keyword
        information it needs to do its job. RFW uses the synonym 'argument' in its
        syntax. This keyword has two arguments/parameters (<code>${text}</code> and 
        <code>${n}</code>). Note that the <code>[ARGUMENTS]</code> always imeadiately 
        follow the keyword name and that each argument/parameter is separated by the 
        usual spaces.<br>
          <code>
*** Keywords ***<br>
Find Nth Character<br>
&nbsp;&nbsp;&nbsp;[ARGUMENTS]&nbsp;&nbsp;&nbsp;${text}&nbsp;&nbsp;&nbsp;${n}<br>
&nbsp;&nbsp;&nbsp;@{characters} =&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;${text}
&nbsp;&nbsp;&nbsp;[RETURN]&nbsp;&nbsp;&nbsp;${characters}[${n}]
          </code>
<br><br>
        The return statement is the means of giving a value back from a keyword. In
        this example we are going to find the Nth character and then we have to give
        it back. The Nth character is returned from the keyword. This could be returned
        to a test or another keyword--whatever called <code>Find Nth Character</code>.
        That kind of flexibility means that this keyword can be used and reused in 
        different settings.
<br><br>
        Few keywords are of much value without parameters and return statements. Maybe
        the keyword is smart enough to find the data it needs elsewhere (e.g. reading
        something off the screen). Maybe it can take some action that is more important
        than returning a value (e.g. push a button). Whatever the case, flexible and 
        reusable keywords are easiest to make when you have parameters that allow input
        to vary and a return statement that shares the result with the calling script.
<br><br>
        <span class="red">NOTE</span> the changes in this step will have NO effect
        because the new keyword isn't called from anywhere in the test cases. We have
        extracted the functionality, but not used it.
      </li>
      <li>
        In this last step we will change the second test case to use the new keyword.
        Because we have already extracted the functionality into the keyword, we only
        have to figure out how to work with that keyword. In this case we pass the state
        and the number to the keyword as parameters. Parameters have to be in the same
        order, but the names of the parameters in the keyword (i.e. <code>${text}</code> 
        and <code>${n}</code>) don't have to match the values we pass (i.e. <code>${state}</code>
        and <code>${num}</code>). Whatever value is returned will be stored in a temporary
        variable <code>${a}</code>. Afterward, we log that text. Run the test again and see
        that all of our changes have not broken the function. In the mean time, we have 
        made a new, reusable keyword that will help with our future testing. That's refactoring.
          <code>
Read Character 2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${state} is my state<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;${num}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}
          </code>
      </li>
      <li>
        Now that we have a reusable keyword, it's much easier to create a series of 
        test cases that use a set of parameters instead of copied code. Let's test 
        this out and use the <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal">Should Be Equal</a>
        keyword. You can copy these test cases and build more based on different
        parameters. Try to make 10 or more. Test them and see the various pass/fail
        answers per case.<br>
          <code>
*** Test Cases ***<br>
Read Character 1<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;${num}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;g<br>
<br>
Read Character 2<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;g<br>
<br>
Read Character 3<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;${num}<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;i<br>
<br>
Read Character 4<br>
&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;Find Nth Character&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2<br>
&nbsp;&nbsp;&nbsp;Log&nbsp;&nbsp;&nbsp;${a}<br>
&nbsp;&nbsp;&nbsp;Should Be Equal&nbsp;&nbsp;&nbsp;${a}&nbsp;&nbsp;&nbsp;r<br>
          </code>
<img src="commandline2.png">
      </li>
    </ol>

    <a name="session2-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw2.robot" download target="_blank">Robot script</a><br>

    <a name="session3"></a><h2>Data-Driven Testing</h2>
    <p>
      Starting with this lesson the instructions will focus less on line-by-line
      code instructions and more on guidance. Training wheels are off, but we aren't
      letting go just yet. This lesson also introduces Data-Driven Testing or DDT
      which is a testing paradigm where one test script is enabled by multiple 
      test <em>cases</em> in the form of parameters. The learner will convert the
      very duplicative last lesson into a DDT paradigm which makes more sense.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session3-instr"></a>
      <li>
        Start by downloading and opening the solution from the previous lesson.
        Resave it as rfw3.robot in the same folder.
      </li>
      <li>
        If you look at the last lesson you will see that the test cases are
        very repetitive. This is not at all unusual. A lot of tests suffer
        from a need to test variations on a theme. Start by creating a new
        keyword that would do the same job with parameters. Create parameters
        for the text, the number, and the expected value.
      </li>
      <li>
        For DDT, we need to identify one keyword, the one we just created
        which will act as the <code>Test Template</code>. In other words,
        this new keyword is the test script and we will activate it with
        different parameters for each test case. We identify the Test 
        Template in the settings.
          <code>
*** Settings ***<br>
Library&nbsp;&nbsp;&nbsp;String<br>
Test Template&nbsp;&nbsp;&nbsp;Read Character
          </code>
<br><br>
        For DDT in RFW the Test Template is <em>required</em>, but there are four
        other specialized keywords that can be defined for a single DDT test. These
        are not required, but may be a good idea. As shown in this image, the 
        designated keywords are executed in a fixed order. While only five keywords
        are used in DDT, you are not limited. Remember that a keyword can call
        another keyword. With these five keywords we are defining five "jumping off"
        points which can contain as much or as little as we want. Which can call
        other keywords if desired.<br>
        <img src="testLoop.png">
<br>
        <code>Suite Setup</code> is called 
        before everything else in order to configure the system for test. This 
        process brings up everything in a default state and may pull up auxiliary
        elements (e.g. the Java-Sikuli server). At the very end of the test is 
        <code>Suite Teardown</code> which performs a complementary service,
        closing things down, shutting off auxiliary services, and posting final 
        data. At the individual test case level there are similar setup and teardown
        keywords. These are more likely used to configure the parameters for a
        specific test (e.g. "Is the light switch currently ON before we start")
        and restoration to the safe, default state after a test. The <code>Test Teardown</code>
        is especially important if the next test will depend on starting in a
        safe space. Are all my services still up? Did I remember to turn off the
        lights? In this test we will only use the <code>Test Template</code> but
        we will see the others soon.
      </li>
      <li>
        Now it's time to address the test cases themselves. In a DDT configuration 
        RFW still has test cases, but it represents each case as just one line of 
        parameters. Based on the test cases demonstrated in the last lesson, these
        are the four test cases one might use. Note that each line has a test name
        which can be quite informative. After that each paramter can be either a 
        value or one of the variables. In this case I added a fourth variable which
        says if I expected to find the matching value. It's counter intuitive, but
        if the test <em>doesn't</em> find a match and I didn't <em>expect</em> to 
        get a match, that's still a pass. We will deal with that in a minute. Use
        your own test cases from lesson 2 to create more test cases following this
        pattern.<br>
          <code>
*** Test Cases ***&nbsp;&nbsp;&nbsp;String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;&nbsp;&nbsp;&nbsp;Char&nbsp;&nbsp;&nbsp;&nbsp;Match<br>
Find g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True<br>
No find g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False<br>
No find r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False<br>
Find r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${state}&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True
          </code>
<br><br>
        You may have noticed that the parameters of the test case are all aligned vertically.
        This was intentionally done with a combination of tabs and spaces (always at least one
        tab or 3 spaces). We have found that aligning your paramters allows you to
        directly compare your test cases and identify problems. On the Test Cases 
        line there are even names for the parameters. They have no effect on RFW
        but are also helpful to the test writer. It's easier to remember what 'g'
        or 'r' means if you put a label on it.
      </li>
      <li>
        Let's add that fourth parameter to our Test Template keyword and decide how
        to handle it. In this case we want to either use <code>Should Be Equal</code>
        or the similarly obvious <code>Should Not Be Equal</code>. And we want our new
        parameter to tell us which to use. The natural way to handle this is to 
        <a href="https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Run%20Keyword%20If">Run Keyword If</a>
        there is a match or not a match. Because <code>Run Keyword If</code> has a built
        in <code>ELSE</code> feature, we can include both actions on the same line.
        Work on your own to build a simple If-Else using the Should and Should Not checks.
        Remember that you can run your test multiple times as you think you have 
        reached incremental stopping points.
      </li>
      <li>
        There is nothing holding us to the state and number we chose. We are free 
        to create entirely new cases. You can add more variables to create standard
        components or you may enter any text you want in any individual test case.
        Experiment and rerun your tests periodically. Be sure to look at the default
        log as well.
      </li>
    </ol>
    <a name="session3-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw3.robot" download target="_blank">Robot script</a><br>

    <a name="session4"></a><h2>Working with a GUI</h2>
    <p>
      In this session, we will investigate the use of a GUI and how
      sikuli and robot framework interact with the GUI. In order to
      simulate a complicate GUI we are going to use the typical calculator
      app available with each operating system. You may
      repeat these steps with any application on your target computer.
      This session will repeat the basic RFW setup and use the RFGUIHelper
      and Sikuli to find the GUI and close it. Later we will expand
      the use of GUIs in testing.<br><br>
      <span class="red">NOTE</span>: You will need to start the SikuliServer
      before running any Sikuli test. Run <code>deployment/RFTest/SikuliEntry/javaserver.bat</code>.
      You may consider making this an automatic process during Suite Startup.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session3-instr"></a>
      <li>
        Start this test by taking a full screen capture of the GUI you
        wish to test against. Keep it simple this time. We just need
        the main window.<br>
        <img src="main.png">
      </li>
      <li>
        Start the GUI helper from <code>/deployment/RFGUIHelper/</code>
        using <code>python3x RFGUIHelp.py</code>. Select File > New. 
        Give a name to your project and navigate to find the screen
        capture you just made. You will see two windows. The table 
        window shows a row for each widget while the picture window 
        shows the image overlaid by all the widgets.<br>
        <img src="helper.png"> 
      </li>
      <li>
        We will create three important widgets for your basic GUI. To
        create a widget, identify the place you want and click the upper-left
        corner. Now click the lower-right corner. This will pop up a 
        third window where you can edit the widget. Note that the edit/add
        window shows the exact image captured between the two corners.<br>
        <img src="addwidget.png"><br><br>
        In the edit/add window you can manually adjust the dimensions of 
        the widget, give it a name, and select a type. Some types have
        additional data. Here we are using the edit/add window to create an anchor.
        An <em>ANCHOR</em> is a portion of the GUI which will not
        change and may be used to find the window on the screen.
        Here we are using the title bar and a window icon as a reliable
        anchor. Note that some GUIs have multiple eligible anchors
        and you may define several. 
      </li>
      <li>
        We will also add a widget for the close button and a movepoint. Your GUI may
        vary. The close <em>BUTTON</em> will, of course, close the application when 
        you click on it. The <em>MOVEPOINT</em> is a place on the GUI which can be 
        dragged to move the window. Most windows are draggable. After you are satisfied
        with each widget, close and save the RFGUIHelper.<br>
        <img src="threewidgets.png">
      </li>
      <li>
        In the same folder as RFGUIHelp.py is the <code>config</code> folder. Inside
        you will find the folder you created and the files for that window. Note that
        each anchor is saved as a .png image file, the original screenshot was copied,
        and a .json file controls the project. Aside from path data for the project,
        the JSON contains a detailed definition of each widget.<br>
        <img src="savefiles.png">
      </li>
      <li>
        Now we are going to examine in detail the way that the GUI configuration file
        is integrated into a RFW test. The file shown below contains all the elements
        you are familiar with and some required for the GUI interaction with Sikuli.
        First, the settings imports both the DataExtraction resource file, of which
        we will hear more, and genericwindow.py. The DataExtraction library enables
        certain Sikuli operations, but genericwindow is the auto-generated GUI for
        your test. In past versions of RFW you would have to create your own low-level
        code to connect with the GUI components. Now, genericwindow contains all the
        keywords you will ever need.<br>
        <img src="robot4.png"><br><br>
        Still, genericwindow is a blank slate until it is configured. In the <code>Start Up</code>
        keyword, we will use the configuration file to change that. On line 24 we
        call <code>Configure Image Library</code> which is required for RFW 3.0 testing.
        Among other things it sets up sikuli and ensures your data is all routed to
        the same folder. On line 27 we call <code>Configure</code> from generic window
        and we pass it the folder for the GUI configuration file. In the overlap you can
        see that the folder name ends with '/' and we include the same data path.
<br><br>
        How does this work? In genericwindow.py (or more correctly the parent class
        window.py) the <code>Configure</code> process parses the config file and 
        gathers all the data you have provided. Among other things it creates a list
        of named widgets and adds them to the GUI. Now you can access any of the
        widgets from keywords built into genericwindow. An example is shown on line
        30 where we call <code>main.Find</code>. The <code>Find</code> function searches
        the screen for any of the Anchors. Once the anchor is found, the relative (x,y)
        location of all widgets is updated. In this case we are using Find to ensure
        the calculator app is on the screen. After finding we can begin testing. Note
        that when the app is closed, <code>Stop Test</code> also calls <code>main.Click</code>
        and selects the closeButton we identified earlier.
<br></br>
        Finally, let's examine the very simple <code>Test Case</code>. It begins and
        ends by calling keywords to setup/stop the test. Note the use of <code>[TEARDOWN]</code>.
        This is a useful feature for test cases (or <code>[KEYWORD TEARDOWN]</code> for
        keywords) to enforce a final cleanup even when the test case has failed. TEARDOWN
        will always run and close the window. The test case also documents the API for
        <code>main</code>. There are two keywords that can be used by the tester to get 
        information contained in the config and verify the GUI is properly working.<br>
        <dl>
          <dt><code>Document API</code></dt><dd>This function creates text, suitable for
          logging, that describes each widget in the window and all of the functions it
          supports.<br><img src="apilog.png"></dd>
          <dt><code>Debug Window</code></dt><dd>This function highlights each widget on
          on the screen for a fraction of a second. It is useful to see where genericwindow
          believes the widgets are and to verify the placement is correct.<br><img src="debug.png"></dd>
        </dl>
      </li>
    </ol>
    <a name="session4-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw4.robot" download target="_blank">Robot script</a><br>
    <a href="prject4.json" download target="_blank">Config JSON</a><br>

    <a name="session5"></a><h2>Recording the Test</h2>
    <p>
      In this session we will create a real test against this application. This is 
      exciting. We are going to create test cases, keywords, and gather data to
      auto-generate a test report. We're going to treat this seriously, even though
      it will still be the calculator app.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session5-instr"></a>
      <li>
        Obviously, the GUI has been reviewed considerably and we have a more
        extensive list of widgets. Note that the table shows all 21. If you
        wanted to edit one, click on that row and the same editor pops up.<br>
        <img src="fullcalc.png">
      </li>
      <li>
        We will start with the same script as the last exercise and this time
        we will set up in a DDT paradigm with test cases for each of the 
        four operations. In settings we align <code>Start Up</code> and <code>Stop Test</code>
        with appropriate DDT keywords. Under test cases we give each case a
        name that fully describes the case. There are four parameters which 
        will enable <code>Operation</code><br>
          <code>
*** Settings ***<br>
Resource&nbsp;&nbsp;&nbsp;&nbsp;DataExtraction.resource<br>
Library&nbsp;&nbsp;&nbsp;&nbsp;genericwindow.py&nbsp;&nbsp;&nbsp;&nbsp;WITH NAME&nbsp;&nbsp;&nbsp;&nbsp;main<br>
<br>
Suite Setup&nbsp;&nbsp;&nbsp;&nbsp;Start Up<br>
Test Template&nbsp;&nbsp;&nbsp;&nbsp;Operation<br>
Suite Teardown&nbsp;&nbsp;&nbsp;&nbsp;Stop Test<br>
<br>
* * *<br>
<br>
*** Test Cases ***<br>
1+5 = 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6<br>
2x8 = 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;multiply&nbsp;&nbsp;&nbsp;&nbsp;16<br>
30 / 6 = 5&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;divide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>
9 - 4 = 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;minus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>
<br>
* * *<br>
<br>
Operation<br>
&nbsp;&nbsp;&nbsp;&nbsp;[ARGUMENTS]&nbsp;&nbsp;&nbsp;&nbsp;${operand1}&nbsp;&nbsp;&nbsp;&nbsp;${operand2}&nbsp;&nbsp;&nbsp;&nbsp;${op}&nbsp;&nbsp;&nbsp;&nbsp;${answer}<br>
&nbsp;&nbsp;&nbsp;&nbsp;main.Find<br>
&nbsp;&nbsp;&nbsp;&nbsp;main.Click&nbsp;&nbsp;&nbsp;&nbsp;clear<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type Number&nbsp;&nbsp;&nbsp;&nbsp;${operand1}<br>
&nbsp;&nbsp;&nbsp;&nbsp;main.Click&nbsp;&nbsp;&nbsp;&nbsp;${op}<br>
&nbsp;&nbsp;&nbsp;&nbsp;Type Number&nbsp;&nbsp;&nbsp;&nbsp;${operand2}<br>
&nbsp;&nbsp;&nbsp;&nbsp;${a} =&nbsp;&nbsp;&nbsp;&nbsp;main.Read&nbsp;&nbsp;&nbsp;&nbsp;${output}<br>
&nbsp;&nbsp;&nbsp;&nbsp;Run Keyword If&nbsp;&nbsp;&nbsp;&nbsp;${a}!=${answer}&nbsp;&nbsp;&nbsp;&nbsp;Fail<br>
          </code>
<br>
        What does the operation (our <code>Test Template</code>) do? First it finds the
        window and clears any previous data. Arguably this could be moved
        to a <code>Test Setup</code>, but we'll leave it here for now. 
        We need to read in a number by clicking buttons, but for now we
        will only name a proposed keyword <code>Type Number</code>. We
        test by typing one number, clicking on the operator (e.g. '+')
        and then typing the next number. After clicking equals we can
        read the output. If there is a mismatch the test fails. This is
        a complete test and you can run the four cases to get a result.
      </li>
      <li>
        To create <code>Type Number</code> we need to use the <a href="https://robotframework.org/robotframework/latest/libraries/String.html#Split%20String%20To%20Characters">Split String To Characters</a>
        seen earlier. In the keyword we will split the number into a list of <code>${digits}</code>.
        This time we will use a <code>FOR</code> loop. RFW uses a FOR
        to look at each character in the list. We will use that opportunity
        to <code>Click</code> on the appropriate button. Note that <br>
          <code>
Type Number<br>
&nbsp;&nbsp;&nbsp;&nbsp;[ARGUMENTS]&nbsp;&nbsp;&nbsp;&nbsp;${NUM}<br>
&nbsp;&nbsp;&nbsp;&nbsp;${digits} =&nbsp;&nbsp;&nbsp;&nbsp;Split String To Characters&nbsp;&nbsp;&nbsp;&nbsp;${NUM}<br>
&nbsp;&nbsp;&nbsp;&nbsp;FOR&nbsp;&nbsp;&nbsp;&nbsp;${digit}&nbsp;&nbsp;&nbsp;&nbsp;IN&nbsp;&nbsp;&nbsp;&nbsp;@{digits}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Run Keyword&nbsp;&nbsp;&nbsp;&nbsp;main.Click&nbsp;&nbsp;&nbsp;&nbsp;${digit}_button<br>
&nbsp;&nbsp;&nbsp;&nbsp;END<br>
          </code>
      </li>
      <li>
        Now, if you run this test and have some problems, that's not 
        surprising. We have a test script, but we aren't gathering any
        data--what we refer to as Objective Quality Evidence or OQE.
        We need to record data to find out what is happening and fix
        the script. What kind of OQE should we gather? This list shows
        the standard which is desired on all tests. These OQE steps
        create an audit trail so that by reviewing the report one
        has as much data as if you had observed the test live.
        <dl>
          <dt>When you start some action...</dt><dd>Mark the action</dd>
          <dt>If something can be seen...</dt><dd>Take a picture</dd>
          <dt>If there was a change in conditions...</dt><dd>Record the data before and after</dd>
          <dt>If you enforced some change...</dt><dd>Verify that it took</dd>
          <dt>If you expected some outcome...</dt><dd>Record what you found<br>Verify it matched</dd>
          <dt>When you finish some action...</dt><dd>Mark the action</dd>
          <dt>If something went wrong...</dt><dd>Fail the test</dd>
        </dl>
      </li>
      <li>
        Let's apply these rules to our test. The first action is when
        we clear any existing data. So let's add some OQE gathering.<br>
          <code>
    Archive Any Previous Data<br>
<br>
    New Test Event&nbsp;&nbsp;&nbsp;&nbsp;${TEST NAME}
          </code>
<br><br>
        First, we will archive OQE data and create a test case. These
        are commands in the DataExtraction library that clear any previous 
        report and start a new line. Archive Any Previous Data may be 
        appropriate for <code>Suite Startup</code>. New Test Event belongs
        in at the start of the <code>Test Template</code> or even the
        <code>Test Startup</code>. The <code>${TEST NAME}</code> is a
        built in variable that always has the case name (e.g. 1 + 5 = 6).<br>
      </li>
      <li>
        Now we can examine appropriate OQE steps added around the one
        line <code>main.Click&nbsp;&nbsp;&nbsp;&nbsp;clear</code>. The
        section begins with <code>Record Action</code> and ends with 
        <code>Keyword Final</code>. These are meant to deliniate this
        action from all others and to create a Green/Red block in the
        report. Note the solid yellow and green lines across the detailed
        report, corresponding to these lines in the script. In addition
        we take a screen capture of the cleared input and read the value.
        Both are recorded in the report and the pass/fail criteria for
        this section is created by <code>Assert OQE Values Equal</code>.
        Looking at the report, it is visually verifiable that the value
        was zero and we have a quick pass/fail verification of that data.
        As promised, if you only read the report you could still verify
        the test results.<br>
        <img src="firstOQE.png">
<br><br>
        It is worth noting that all of these OQE keywords come from <code>DataExtraction.resource</code>.
        That is a small library with full documentation at <code>deployment/RFTest/Doc/dataextraction.html</code>.
        Broadly, the library has keywords for report formatting (action, 
        soft, and hard breaks), asserting pass/fail criteria (e.g. two 
        values are equal), and recording test data. There are also data
        charts (courtesy of <a href="https://bsdillon.github.io/DahlgrenTest/html/RFDocumentation/charting/index.html">chart.js</a>)
        for data reporting per test or per suit of tests. Finally, note
        the name <code>Keyword Final</code>. These one keyword is so
        typical as part of <code>TEARDOWN</code> that it was specifically
        added for the purpose. Recall that teardown is enforced even if
        the keyword or test fails. Keyword Final captures the final state
        and adds that content to the report. As in the example shown above
        if the criteria passed a green block and line will be added to
        the report. If the criteria failed... you get red. All of this suggests
        that the various data gathering and reporting around the clearing
        action may be extracted into its own keyword.
      </li>
      <li>
        One may debate which sections of the test form a cohesive "unit"
        worthy of OQE and indeed its own keyword. Two criteria should be
        considered: Is the block repeated anywhere in the test? Will the 
        block be reused by any other test? If either answer is yes, it 
        should be extracted in this way. We can do something similar with
        the two operands and the operator. In effect all the next block
        until we hit '=' is one action. We can wrap it with OQE and expect
        that <code>Math Problem</code> is a reusable component in future
        tests. Extract those lines and add the following OQE:<br>
        <ul>
          <li>Record the action and add Keyword Final.</li>
          <li>Take a picture of each complete number</li>
          <li>Read the value of each complete number</li>
          <li>Verify that the numbers match expectations</li>
          <li>Record the final result, maybe adding a picture</li>
        </ul>
      </li>
      <li>
        In doing the last activity, you may have noticed an oversight
        that caused the test to fail. It was missing the line <code>main.Click&nbsp;&nbsp;&nbsp;&nbsp;equals</code>.
        Not only does adding OQE help us to verify test results, but
        it is also a valuable way of verifying the test script. If
        an action happens, we need OQE. If we need OQE, then the action
        should be verified. Creating this new keyword should add a second
        block to our report and additional data in the detailed report.<br>
        <img src="secondOQE.png">
      </li>
      <li>
        While it's nice to see all the green Pass results, we aren't quite done.
        We need to verify the final result matches our expectations.
        Right now we are using <code>Fail</code> but that doesn't produce
        useful OQE. Go back to the final action. We already recorded
        the result in both picture and value. Now, we just need to
        verify the results and summarize our test results. Let's backtrack
        to <code>Clear Data</code> and <code>Math Problem</code>. In
        each case the last line (just before Keyword Final) should be
        a variant on <code>Run Keyword If&nbsp;&nbsp;&nbsp;&nbsp;${a}!='PASS'&nbsp;&nbsp;&nbsp;&nbsp;Fail</code>.
        This means that each keyword has the potential to fail the
        whole test. Within our test case we can take some creative
        steps to ensure a more useful output. In each case:<br>
        <ul>
          <li>You can anticipate the cause of failure for that keyword</li>
          <li>You can report the final result</li>
          <li>You can update in the event that the keyword passes</li>
        </ul>
      </li>
    </ol>
    <a name="session5-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw5.robot" download target="_blank">Robot script</a><br>
    <a href="project5.json" download target="_blank">Config JSON</a><br>

    <a name="session6"></a><h2>Resource Files</h2>
    <p>
      This last session will focus on resource files. Up to now
      we have used <code>.robot</code> files, but now we will 
      learn how and when to create a <code>.resource</code> file.
      Recall that robot files are <i>tests</i>. As such they are
      designed for one use only. In order to create reusable code
      for use in multiple tests, you must use a resource file. In
      this session we will turn the last test into a resource file.
    </p>

    <h3>Instructions</h3>
    <ol><a name="session6-instr"></a>
      <li>
        Let's start with the solution file from the last test. In this
        case we will copy and rename as a <code>.resource</code>. Right
        away there are things that we can strip out because they should
        be part of a test. Instead, this resource will be used for the
        standard calculator.<br>
        <ul>
          <li><code>${DATA PATH}</code> should be removed from variables.</li>
          <li>Get rid of all the <code>*** Test Cases ***</code>.</li>
          <li>It is debatable if the DataExtraction resource file should remain,
          but it certainly does no <em>harm</em>. On the other hand all the 
          DDT keyword definitions belong only in a test file.</li>
          <li>The <code>Operation</code> keyword was the Test Template
          and it has no business in the resource file.</li>
          <li>For similar reasons, remove <code>Start Up</code> and <code>Stop Test</code>.</li>
        </ul>
      </li>
      <li>
        Just as we removed things that had no business in a resource file,
        there are some things we should either add or rescue from the removed 
        code.<br>
        <ul>
          <li>Create a new keyword to start the calculator. You can use pieces
          rescued from <code>Start Up</code>.</li>
          <li>Create a new keyword to close the calculator using pieces from 
          <code>Stop Test</code>.</li>
          <li><code>Type Number</code> is set up for numbers only. We might
          consider adding two new features. It is possible that you could add
          a regular expression check to <a href='https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Match%20Regexp'>validate number formats</a>. It really
          depends on how complex your tests would be.<br>
          <ul>
            <li>Flipping the sign -/+ when the number includes '&minus;'</li>
            <li>Inserting a decimal point when the number includes '.'</li>
          </ul>
          </li>
          <li>Add buttons to the GUI for square, square root, etc.</li>
          <li>Create new "problem" keywords for each of these functions. Again
          for this example you can get as detailed as you like.</li>
        </ul>
      </li>
      <li>
        Don't forget to add the OQE for your report. At the very least you have
        actions to record and if you can determine what the correct course of 
        action should be, validate that as well.
      </li>
      <li>
        The goal of this resource is that it can be used to operate the calculator,
        perhaps as part of a larger test. It should have keywords that allow a test
        to start the calculator, type various numbers, perform various operations, 
        read and clear the results, and close the calculator again. We don't have
        any test in mind at this time, just preparation for potential uses.
      </li>
      <li>
        After refactoring the test file into a resource, we can return to the 
        <code>.robot</code> file. Create a copy and rewrite to include <em>just</em>
        the test portion. As we intended, import the new resource file and use the
        new keywords to recreate the same test effects.
      </li>
    </ol>
    <a name="session6-solut"></a><h3>Solution Scripts</h3>
    <a href="rfw6.robot" download target="_blank">Robot script</a><br>
    <a href="rfw6.resource" download target="_blank">Resource script</a><br>
    <a href="project6.json" download target="_blank">Config JSON</a><br>
  </body>
</html>
