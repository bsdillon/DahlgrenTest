things that are complete:
1) checking all input at the csv file selection now. 
	Errors when:
		- the header names are not "file, line, error, property"
		- the file has a property that matches any of the preset property names
		--if the files selected have an error, they are not added to the selection list and a pop-up box appears. All clean files are added to the list
		crash everything when errors, validate file at csv input -- validate edge names
	CSV input files are now checked at file selection to ensure they contain specific headers/properties. PropertiedObject now contains a static list of ALL properties shared among ALL nodes. PropertiedObject (Get/Set/RemoveProperty/etc. functions now have overloaded functions that use strings instead of Node Properties). Removal of MiscData property in exhange for module property addition from the csv file itself.
2) now using a static list for the header of the node files and everything seems to be working
	for each header value in the static list:
		if(header.value exists) -> print the value
		else -> print "," goto next header 
3) all of the methods within propertiedobject have string overloads now
	this affected a good number of functions within the gephinode/gephi edge related files, but I believe all errors are fixed now
		--mainly output based functions, same functionality
4) created a static dictionary of properties that is used to create the header/output columns 
	-update it everytime a property is added to the node specific properties list
	-output the all inclusive list of headers when a file is ready to output
when you add properties in programmatically, it creates a weird issue.
--each line is a separate node. each node has different number of properties
--the header for each file uses the first node's properties as the header. not always all inclusive
--the properties are added into each node as they are presented in the csv file.
----this generally only goes out to column M of an excel file.
----if a line in the csv file has errorPropA, errorPropB, ... errorPropJ, it would have 10 extra columns.(columns N-W)
----if a different line only has errorPropH, it fill in column N. 
	--the problem is: the first line would have errorPropH in column U, but the second line would have it in column N
5) changed the way that edges were defined and outputted, adding the ability to track specific line numbers of graphnodes/edges(hindered ability to trace code down to specific lines)
	The line numbers for each edge/node were associated with the parent scope of that particular edge
6) created tracing functions that define a dictionary of affected nodes
	-e.g. TraceField, TraceParameter, TraceReturnValue, etc.
	-these functions are unique according to the item they trace
	-an output file is created from the dictionary of affected nodes that is populated by the tracing functions
7) used those affected nodes and their parent and children relationships within a recursive function to find and print out all of the affected graphnodes in a tree format	




Notes:
-asserts are not accounted for
-gephinode properties are added from user-inputted csv files after the .gph is written.
---the .gph might need an update to include for use within gephi
-future idea: take simulated data, mark it, terminate tracing at that point



