using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoftwareAnalyzer2.Structure.Node
{
    /// <summary>
    /// IModifiable extends the INavigable interface by allowing the using class to modify
    /// the contents of individual nodes and the structure of the AST. These modifications
    /// include recursive actions which can significantly alter the structure of the AST 
    /// both from the bottom up and the the top down.
    /// </summary>
    public interface IModifiable : INavigable
    {
        /// <summary>
        /// Unique method which makes this node a TypeDeclaration and copies the type
        /// and classification. Throws an InvalidOperationException if both items are 
        /// not present in node.
        /// </summary>
        /// <param name="node"></param>
        void ModifyToTypeDeclaration(IModifiable node);

        #region Modify Basic Attributes
        /// <summary>
        /// True for all nodes generated by the original parse or promoted as if they were 
        /// part of the original parse. False for all nodes generated for structure alone.
        /// </summary>
        bool IsNatural { get; set; }

        /// <summary>
        /// Separate setters to allow controlled input to Node property from different types.
        /// Unknown natural string from the original AST
        /// </summary>
        /// <param name="p"></param>
        void SetNode(string p);

        /// <summary>
        /// Separate setters to allow controlled input to Node property from different types.
        /// </summary>
        /// <param name="members"></param>
        void SetNode(Members members);

        /// <summary>
        /// Separate setters to allow controlled input to Node property from different types.
        /// </summary>
        /// <param name="m"></param>
        void SetNode(NodeType m);

        /// <summary>
        /// Set the origin file of this node from the source node given.
        /// </summary>
        /// <param name="source"></param>
        void CopyFile(IModifiable source);

        /// <summary>
        /// Produces node tree which is similar to the tree below this point. All internal 
        /// references are preserved, but the head answer and tree returned will not be 
        /// linked with the original tree in any way.
        /// </summary>
        /// <returns></returns>
        IModifiable Clone();

        /// <summary>
        /// Assigns line values for this node by copying the given node.
        /// </summary>
        /// <param name="source"></param>
        void SetLine(IModifiable source);

        #region Modify Code
        /// <summary>
        /// Removes any and all instances of the given characters creating new nodes from 
        /// the remaining string tokens.
        /// </summary>
        /// <param name="excluded_characters"></param>
        /// <returns></returns>
        List<IModifiable> CreateNodesFromCode(char[] excluded_characters);

        /// <summary>
        /// Adds a code segment to the node, updating the line and character ranges for 
        /// the node. Separate code elements should be added incrementally and in order.
        /// </summary>
        /// <param name="codeSnippet"></param>
        /// <param name="line"></param>
        /// <param name="charStart"></param>
        void AddCode(string codeSnippet, int line, int charStart);

        /// <summary>
        /// Adds a code segment to the node, taking the line and character ranges from 
        /// the lineSource. Meant to be used for one and only code segment.
        /// </summary>
        /// <param name="codeSnippet"></param>
        /// <param name="lineSource"></param>
        void AddCode(string codeSnippet, IModifiable lineSource);

        /// <summary>
        /// Removes all code elements from this node
        /// ClearAll: removes the code and erases any character or line data
        /// KeepLine: removes the code, but remembers the line it was on
        /// KeepAll: keeps all line and character data.
        /// </summary>
        /// <param name="o"></param>
        void ClearCode(ClearCodeOptions o);

        /// <summary>
        /// Directly copies single code element at given index 
        /// from the given source
        /// Throws an error if there is no code at that index.
        /// </summary>
        /// <param name="source"></param>
        /// <param name="index"></param>
        void CopyCode(IModifiable source, int index);

        /// <summary>
        /// Directly copies all code elements, the line, and the character ranges 
        /// from the given source
        /// </summary>
        /// <param name="source"></param>
        void CopyCode(IModifiable source);

        /// <summary>
        /// Removes any and all instances of the given characters from the Code
        /// </summary>
        /// <param name="excluded_characters"></param>
        void SimplifyCode(char[] excluded_characters);
        #endregion

        #region Modify Children
        /// <summary>
        /// Allows single child to be removed from the collection.
        /// Child is identified by reference.
        /// Throws an exception if the child is not found
        /// </summary>
        /// <param name="node"></param>
        void RemoveChild(IModifiable node);

        /// <summary>
        /// Removes all children in the collection, breaking the parent-child relationship.
        /// </summary>
        void DropChildren();

        /// <summary>
        /// Finds the location of currentChild within the collection and replaces it 
        /// with the nextChild preserving the order of the collection
        /// </summary>
        /// <param name="currentChild"></param>
        /// <param name="nextChild"></param>
        void ReplaceChild(IModifiable currentChild, IModifiable nextChild);
        #endregion
        #endregion

        #region Recursive Modification Functions
        /// <summary>
        /// Recursive function which alters the NodeType of all nodes which match the currentNode type. 
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        void Rename(string currentNodeType, Members nextNodeType);

        /// <summary>
        /// Recursive function which alters the NodeType of all nodes which match the currentNode type. 
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        void Rename(string currentNodeType, string nextNodeType);

        /// <summary>
        /// Recursive function which renames and modifies all nodes which match the 
        /// currentNode type. This function applies the modification from the root 
        /// up to the most distant leaf nodes.
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        /// <param name="modifier"></param>
        void RootUpModify(string currentNodeType, Members nextNodeType, Action<IModifiable> modifier);

        /// <summary>
        /// Recursive function which renames and modifies all nodes which match the 
        /// currentNode type. This function applies the modification from the root 
        /// up to the most distant leaf nodes.
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        /// <param name="modifier"></param>
        void RootUpModify(string currentNodeType, string nextNodeType, Action<IModifiable> modifier);

        /// <summary>
        /// Recursive function which renames and modifies all nodes which match the 
        /// currentNode type. This function applies the modification from the root 
        /// up to the most distant leaf nodes.
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        /// <param name="modifier"></param>
        void RootUpModify(Members currentNodeType, Members nextNodeType, Action<IModifiable> modifier);

        /// <summary>
        /// Recursive function which renames and modifies all nodes which match the 
        /// currentNode type. This function applies the modification from the most 
        /// distant leaf nodes down to the root.
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        /// <param name="modifier"></param>
        void LeafDownModify(string currentNodeType, string nextNodeType, Action<IModifiable> modifier);

        /// <summary>
        /// Recursive function which renames and modifies all nodes which match the 
        /// currentNode type. This function applies the modification from the most 
        /// distant leaf nodes down to the root.
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        /// <param name="modifier"></param>
        void LeafDownModify(string currentNodeType, Members nextNodeType, Action<IModifiable> modifier);

        /// <summary>
        /// Recursive function which renames and modifies all nodes which match the 
        /// currentNode type. This function applies the modification from the most 
        /// distant leaf nodes down to the root.
        /// </summary>
        /// <param name="currentNodeType"></param>
        /// <param name="nextNodeType"></param>
        /// <param name="modifier"></param>
        void LeafDownModify(Members currentNodeType, Members nextNodeType, Action<IModifiable> modifier);

        /// <summary>
        /// Recursive function similar to RootUpModify. In this variant, the code and not the
        /// NodeType will indicate if the modification is valid for each node. The modifier
        /// function should make that determination as the process may be complicated.
        /// </summary>
        /// <param name="modifier"></param>
        void CodeModify(Action<IModifiable> modifier);
        #endregion

        #region Final Modifications
        /// <summary>
        /// Determines the range in (lines and char) of all children and uses that to define the range for the parent
        /// Inverts the tree so parents inherit this trait from their children.
        /// </summary>
        void NormalizeLines();

        /// <summary>
        /// Collapses all nodes in the tree below this point which match the given criteria
        /// This removes them from the tree and promotes the child of that child into that place
        /// </summary>
        /// <param name="specificNode"></param>
        /// <returns></returns>
        IModifiable Collapse(string specificNode);

        /// <summary>
        /// Collapses all nodes in the tree below this point which match the given criteria
        /// This removes them from the tree and promotes the child of that child into that place
        /// </summary>
        /// <param name="specificNode"></param>
        /// <returns></returns>
        IModifiable Collapse(Members specificNode);

        /// <summary>
        /// Collapses all nodes in the tree below this point which match the given criteria
        /// This removes them from the tree and promotes the child of that child into that place
        /// </summary>
        /// <param name="specificNode"></param>
        /// <param name="specificCode"></param>
        /// <returns></returns>
        IModifiable Collapse(string specificNode, string specificCode);
        #endregion
    }
}
